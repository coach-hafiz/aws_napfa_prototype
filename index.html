<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>QR Lap Tracker — Responsive + Recording</title>
<style>
  :root { --accent:#015871; --bg:#f7f7f7; }
  * { box-sizing: border-box; }
  body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:#111; }

  /* Responsive split: portrait = rows; landscape = columns */
  .app {
    display: grid;
    width: 100vw; height: 100vh;
  }
  @media (orientation: portrait) {
    .app { grid-template-rows: 1fr 1fr; grid-template-columns: 1fr; }
    .stage { grid-row: 1 / 2; }
    .results { grid-row: 2 / 3; }
  }
  @media (orientation: landscape) {
    .app { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr; }
    .stage { grid-column: 1 / 2; }
    .results { grid-column: 2 / 3; }
  }

  .stage { position: relative; background:#000; }
  canvas#view { width: 100%; height: 100%; display:block; background:#000; }

  .controls {
    position: absolute; top: 8px; left: 8px; right: 8px;
    display: flex; flex-wrap: wrap; gap: 8px; align-items: center;
    background: rgba(255,255,255,0.92); padding: 8px; border-radius: 12px;
  }
  button {
    background: var(--accent); color:#fff; border:0; border-radius: 10px;
    font-weight: 700; padding: 10px 14px; min-width: 110px; font-size: 15px;
  }
  button.secondary { background:#666; }
  input, select { height: 40px; padding: 0 10px; border:1px solid #ccc; border-radius:10px; font-size:15px; background:#fff; }
  .timer { font-variant-numeric: tabular-nums; font-weight: 800; min-width: 80px; }

  .results { padding: 10px; overflow: hidden; display: flex; flex-direction: column; gap: 10px; }
  .cards {
    flex:1; min-height: 0; overflow: auto; background:#fff; border:1px solid #eee; border-radius: 12px;
  }
  table { width: 100%; border-collapse: collapse; }
  thead th { position: sticky; top:0; background:var(--accent); color:#fff; padding: 8px; }
  td, th { padding: 8px; border-bottom: 1px solid #f0f0f0; text-align: center; font-size: 14px; }
  tr.done { background: #e9f6ec; }
  .hint, .log { font-size: 12px; color:#555; white-space: pre-wrap; }

  .badge { background:#eee; border-radius:6px; padding:2px 8px; font-size:12px; }
</style>
</head>
<body>
<div class="app">
  <!-- VIDEO + CONTROLS (always half the screen) -->
  <section class="stage">
    <canvas id="view" aria-label="Camera + overlay"></canvas>
    <div class="controls">
      <button id="enableBtn">Enable Camera</button>
      <button id="startBtn" class="secondary" disabled>Start</button>
      <button id="stopBtn"  class="secondary" disabled>Stop</button>
      <button id="exportBtn" class="secondary" disabled>Export CSV</button>
      <span class="timer" id="timer">00:00</span>
      <label>Req. Laps
        <select id="reqLaps">
          <option>1</option><option>2</option><option>3</option>
          <option selected>4</option><option>5</option><option>6</option><option>7</option><option>8</option>
        </select>
      </label>
      <label>Show video <input type="checkbox" id="showVideo"></label>
      <span class="badge" id="status">idle</span>
    </div>
  </section>

  <!-- RESULTS (always half the screen) -->
  <section class="results">
    <div class="cards">
      <table>
        <thead><tr><th>Runner ID (QR)</th><th>Laps</th><th>Finish</th></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
    <div class="hint">
      • Use large, matte QR codes (e.g., 8–10 cm).<br/>
      • Good light, hold steady while crossing the red line.<br/>
      • This app records the whole session (canvas with overlays) once you press Start.
    </div>
    <div class="log" id="log"></div>
  </section>
</div>

<!-- jsQR (pure JS QR reader) -->
<script defer src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

<script>
(function(){
  // DOM
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const enableBtn = document.getElementById('enableBtn');
  const startBtn  = document.getElementById('startBtn');
  const stopBtn   = document.getElementById('stopBtn');
  const exportBtn = document.getElementById('exportBtn');
  const timerEl   = document.getElementById('timer');
  const statusEl  = document.getElementById('status');
  const tbody     = document.getElementById('tbody');
  const reqLapsEl = document.getElementById('reqLaps');
  const showVideoCb = document.getElementById('showVideo');
  const logEl = document.getElementById('log');

  // State
  let video=null, stream=null;
  let w=1280, h=720, guideY= Math.round(h*0.7);
  let running=false, counting=false, startTime=0, tick=null;
  const COOLDOWN=1500;           // ms per ID
  const runners = {};            // id -> {laps, done, last, finish}
  let frameCount=0;

  // Recording (canvas stream)
  let recMediaRecorder=null, recChunks=[], recording=false;

  // Debug tiny video preview (optional)
  let debugVideo = document.createElement('video');
  debugVideo.playsInline = true; debugVideo.muted = true; debugVideo.style.display='none';
  document.body.appendChild(debugVideo);
  showVideoCb.addEventListener('change', ()=> debugVideo.style.display = showVideoCb.checked ? 'block' : 'none');

  // Helpers
  const setStatus=(t)=>{ statusEl.textContent = t; console.log(t); };
  const log = (...a)=>{ console.log(...a); logEl.textContent = (logEl.textContent + '\n' + a.join(' ')).trim().slice(-4000); };
  const msToMMSS = (ms)=>{ const s=Math.floor(ms/1000); return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`; };

  function ensureRow(id){
    if (runners[id]) return;
    runners[id] = { laps:0, done:false, last:0, finish:'-' };
    const tr = document.createElement('tr'); tr.id = 'r-'+CSS.escape(String(id));
    tr.innerHTML = `<td>${id}</td><td id="laps-${CSS.escape(String(id))}">0</td><td id="fin-${CSS.escape(String(id))}">-</td>`;
    tbody.appendChild(tr);
  }
  function updateRow(id){
    const safeId = CSS.escape(String(id));
    document.getElementById('laps-'+safeId).textContent = runners[id].laps;
    document.getElementById('fin-'+safeId).textContent  = runners[id].finish;
    if (runners[id].done) document.getElementById('r-'+safeId).classList.add('done');
  }
  function countLap(id){
    if (!counting) return;
    const now = Date.now();
    const r = runners[id];
    if (r.done) return;
    if (now - r.last < COOLDOWN) return;
    r.laps++; r.last = now;
    const req = parseInt(reqLapsEl.value,10);
    if (r.laps >= req){ r.done=true; r.finish = msToMMSS(now - startTime); }
    updateRow(id);
    setStatus(`Scan ${id}: lap ${r.laps}${r.done?' — finished':''}`);
  }

  // Camera
  async function enableCamera(){
    if (!navigator.mediaDevices?.getUserMedia){
      setStatus('getUserMedia not supported'); return;
    }
    setStatus('Requesting camera…');
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720} },
        audio:false
      });
    } catch(e){
      setStatus('Camera error: '+(e.message||e)); return;
    }
    video = document.createElement('video');
    video.srcObject = stream; video.playsInline = true; video.muted = true; video.autoplay = true;
    debugVideo.srcObject = stream;

    try { await video.play(); } catch(e){}
    await new Promise(r=>{ if (video.readyState>=2) r(); else video.onloadedmetadata = r; });

    w = video.videoWidth || w; h = video.videoHeight || h;
    canvas.width = w; canvas.height = h;
    guideY = Math.round(h*0.7);

    enableBtn.disabled = true; startBtn.disabled = false; stopBtn.disabled = true; exportBtn.disabled = true;
    if (!running){ running=true; requestAnimationFrame(loop); }
    setStatus('Camera ready. Aim QR at the red line.');
  }

  // Multi-QR detection via tiling (jsQR normally returns one best; we scan tiles)
  function detectMultipleQR(imageData, width, height){
    const found = [];
    const seen = new Set();

    function pushResult(code, offsetX=0, offsetY=0, scaleX=1, scaleY=1){
      if (!code) return;
      const id = code.data?.trim();
      if (!id) return;
      const key = id + '|' + Math.round((code.location?.topLeftCorner?.x||0)+offsetX);
      if (seen.has(key)) return;
      seen.add(key);

      // compute center with offsets
      const loc = code.location;
      const pts = [
        loc.topLeftCorner, loc.topRightCorner, loc.bottomRightCorner, loc.bottomLeftCorner
      ].filter(Boolean);

      let cx=0, cy=0;
      for (const p of pts){
        cx += offsetX + p.x*scaleX;
        cy += offsetY + p.y*scaleY;
      }
      const n = pts.length || 1;
      cx/=n; cy/=n;

      found.push({ id, cx, cy, corners: pts.map(p=>({x:offsetX+p.x*scaleX, y:offsetY+p.y*scaleY})) });
    }

    // 1) whole frame
    try {
      const code = jsQR(imageData.data, width, height, { inversionAttempts: "attemptBoth" });
      if (code) pushResult(code, 0,0,1,1);
    } catch(e){}

    // 2) tiles (3x3)
    const cols=3, rows=3;
    const tileW = Math.floor(width/cols), tileH = Math.floor(height/rows);
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const x0 = c*tileW, y0 = r*tileH;
        const w2 = (c===cols-1) ? (width - x0) : tileW;
        const h2 = (r===rows-1) ? (height - y0) : tileH;
        try {
          const tile = ctx.getImageData(x0,y0,w2,h2);
          const code = jsQR(tile.data, w2, h2, { inversionAttempts: "attemptBoth" });
          if (code) pushResult(code, x0, y0, 1, 1);
        } catch(e){}
      }
    }
    return found;
  }

  // Recording (records the canvas with overlays)
  function startRecording(){
    if (recording) return;
    const fps = 30;
    const stream = canvas.captureStream(fps);
    const mimeCandidates = [
      'video/webm;codecs=vp9',
      'video/webm;codecs=vp8',
      'video/webm',
      'video/mp4;codecs=h264', // may not be allowed without transcoding
      'video/mp4'
    ];
    let mimeType = '';
    for (const m of mimeCandidates){
      if (MediaRecorder.isTypeSupported(m)){ mimeType = m; break; }
    }
    try{
      recMediaRecorder = new MediaRecorder(stream, mimeType?{mimeType}:{});
    }catch(e){
      // fallback: no options
      recMediaRecorder = new MediaRecorder(stream);
    }
    recChunks = [];
    recMediaRecorder.ondataavailable = e => { if (e.data && e.data.size) recChunks.push(e.data); };
    recMediaRecorder.onstop = saveRecording;
    recMediaRecorder.start();
    recording = true;
    log('Recording started with mime:', recMediaRecorder.mimeType);
  }

  function saveRecording(){
    const blob = new Blob(recChunks, { type: recMediaRecorder.mimeType || 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.href = url; a.download = `run_session_${ts}.webm`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    recording = false;
    log('Recording saved.');
  }

  function stopRecording(){
    if (recMediaRecorder && recording){
      try { recMediaRecorder.stop(); } catch(e){}
    }
  }

  // Loop
  function loop(){
    if (!running) return;

    if (video && video.readyState >= 2){
      // draw video to canvas (fills canvas size)
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    // red start line
    ctx.strokeStyle = 'red';
    ctx.lineWidth = Math.max(3, canvas.height/240);
    ctx.beginPath(); ctx.moveTo(0, guideY); ctx.lineTo(canvas.width, guideY); ctx.stroke();

    // detection (throttled)
    frameCount++;
    if (video && video.readyState >= 2){
      // Read frame and detect multiple QR
      const frame = ctx.getImageData(0,0,canvas.width,canvas.height);
      const dets = detectMultipleQR(frame, canvas.width, canvas.height);

      if (dets.length){
        ctx.save();
        ctx.strokeStyle='lime'; ctx.fillStyle='rgba(0,255,0,0.25)'; ctx.lineWidth=Math.max(2, canvas.height/360);
        for (const d of dets){
          // draw center marker
          ctx.beginPath(); ctx.arc(d.cx,d.cy, Math.max(4, canvas.height/200), 0, Math.PI*2); ctx.fill();
          // quick box if corners available
          if (d.corners?.length===4){
            ctx.beginPath();
            ctx.moveTo(d.corners[0].x, d.corners[0].y);
            for(let i=1;i<4;i++) ctx.lineTo(d.corners[i].x, d.corners[i].y);
            ctx.closePath(); ctx.stroke();
          }

          const id = d.id; // text content of QR
          ensureRow(id);
          if (counting && Math.abs(d.cy - guideY) < Math.max(16, canvas.height/60)) {
            countLap(id);
          }
        }
        ctx.restore();
      }
    }

    requestAnimationFrame(loop);
  }

  // Timer
  function startTimer(){
    startTime = Date.now();
    timerEl.textContent = '00:00';
    if (tick) clearInterval(tick);
    tick = setInterval(()=> timerEl.textContent = msToMMSS(Date.now()-startTime), 1000);
  }
  function stopTimer(){
    if (tick) clearInterval(tick);
    tick = null;
  }

  // Buttons
  enableBtn.addEventListener('click', async ()=>{
    enableBtn.disabled = true;
    try { await enableCamera(); }
    catch(e){ setStatus('Enable failed: '+(e.message||e)); enableBtn.disabled=false; }
  });

  startBtn.addEventListener('click', ()=>{
    if (!video) { setStatus('Enable camera first'); return; }
    if (counting) return;
    counting = true;
    startTimer();
    startRecording();     // start session recording (canvas stream)
    startBtn.disabled = true; stopBtn.disabled = false; exportBtn.disabled = true;
    setStatus('Counting started + recording');
  });

  stopBtn.addEventListener('click', ()=>{
    if (!counting) return;
    counting = false;
    stopTimer();
    // mark DNF for unfinished
    for (const id of Object.keys(runners)){
      const r = runners[id]; if (!r.done){ r.finish = 'DNF'; updateRow(id); }
    }
    stopRecording();      // auto-save in onstop
    startBtn.disabled = false; stopBtn.disabled = true; exportBtn.disabled = false;
    setStatus('Stopped. Video saved.');
  });

  exportBtn.addEventListener('click', ()=>{
    const rows = [['Runner ID (QR)','Laps','Finish']];
    for (const id of Object.keys(runners)){
      const r = runners[id];
      rows.push([id, String(r.laps), r.finish]);
    }
    const csv = rows.map(r=> r.map(c=> (String(c).includes(',')?`"${String(c).replace(/"/g,'""')}"`:c)).join(',')).join('\n');
    const blob = new Blob([csv], { type:'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download=`qr_laps_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  // Handle resize/orientation: keep canvas sizing in sync
  window.addEventListener('resize', ()=>{ if (video){ canvas.width = video.videoWidth; canvas.height = video.videoHeight; guideY = Math.round(canvas.height*0.7); }});
  window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ if (video){ canvas.width = video.videoWidth; canvas.height = video.videoHeight; guideY = Math.round(canvas.height*0.7); }}, 300); });

})();
</script>
</body>
</html>