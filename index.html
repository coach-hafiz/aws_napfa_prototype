<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ArUco Lap Counter</title>
<style>
  :root{ --accent:#0b74a6; --bg:#f6fbff }
  *{ box-sizing:border-box }
  body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:var(--bg); color:#111 }
  .bar{ position:sticky; top:0; z-index:30; background:#fff; border-bottom:1px solid #e6eef6; padding:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  button{ height:40px; min-width:100px; padding:0 12px; font-weight:700; font-size:14px; color:#fff; background:var(--accent); border:0; border-radius:10px; cursor:pointer }
  button.secondary{ background:#6c757d }
  select,input[type=number]{ height:40px; padding:0 8px; border-radius:10px; border:1px solid #d7e3ea; background:#fff }
  .timer{ font-variant-numeric:tabular-nums; font-weight:700; min-width:80px; text-align:center; }
  .wrap{ background:#000; display:flex; justify-content:center; align-items:center }
  canvas#view{ display:block; width:100%; height:auto; touch-action:none; background:#000 }
  .panel{ padding:12px }
  .tbl{ max-height:44vh; overflow:auto; background:#fff; border:1px solid #e6eef6; border-radius:10px }
  table{ width:100%; border-collapse:collapse }
  thead th{ position:sticky; top:0; z-index:1; background:var(--accent); color:#fff; font-weight:700; padding:8px }
  th,td{ padding:8px; text-align:center; border-bottom:1px solid #f0f4f6; font-size:14px }
  tr.done{ background:#eaf8f3 }
  .log{ font-size:12px; color:#333; margin-top:8px; white-space:pre-wrap; max-height:12vh; overflow:auto; background:#fff; border:1px solid #e6eef6; padding:8px; border-radius:8px }
  .muted{ color:#666; font-size:13px }
  .status{ padding:6px 10px; border-radius:999px; background:#eaf2f8; color:#034c66; font-weight:700 }
  .small{ font-size:13px; color:#334 }
  .overlay-debug{ position:absolute; left:8px; top:8px; padding:6px 10px; background:rgba(0,0,0,0.6); color:#fff; border-radius:8px; font-size:12px; z-index:30 }
  .lib-actions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .lib-actions button{ background:#4b5563 }
</style>
</head>
<body>
  <div class="bar">
    <button id="enableBtn">Enable Camera</button>
    <button id="startBtn" class="secondary" disabled>Start</button>
    <button id="stopBtn" class="secondary" disabled>Stop</button>

    <div style="display:flex;align-items:center;gap:8px;margin-left:8px">
      <div class="timer" id="timer">00:00</div>
      <div class="small">Laps:</div>
      <select id="reqLaps">
        <script>for(let i=1;i<=20;i++){document.write(`<option value="${i}">${i}</option>`)}</script>
      </select>
    </div>

    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <div class="status" id="status">Idle</div>
    </div>
  </div>

  <div style="padding:8px;background:#fff;border-bottom:1px solid #e6eef6;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
    <label class="small">Cooldown (ms): <input id="cooldown" type="number" value="2000" min="100" style="width:110px"></label>
    <label class="small">Detect every N frames: <input id="detectEvery" type="number" value="2" min="1" style="width:70px"></label>
    <label class="small">Line tolerance (px): <input id="tol" type="number" value="24" min="4" style="width:70px"></label>

    <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
      <div class="lib-actions">
        <button id="libRetryBtn" class="secondary">Retry OpenCV Load</button>
      </div>
      <div class="small" style="margin-left:6px">Library: <strong id="libStatus">loading...</strong></div>
    </div>
  </div>

  <div class="wrap" style="position:relative">
    <canvas id="view"></canvas>
    <div id="dbg" class="overlay-debug" style="display:none">debug</div>
  </div>

  <div class="panel">
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <button id="exportBtn" class="secondary" disabled>Export CSV</button>
      <div class="muted">Export enabled after Stop.</div>
    </div>

    <div class="tbl">
      <table>
        <thead><tr><th>Tag ID</th><th>Laps</th><th>Finish</th></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <div class="log" id="log">Logs will appear here.</div>
  </div>

  <!-- We'll dynamically load OpenCV.js (ArUco via opencv_contrib) with retries -->
  <script>
  // Config: CDN list to try for opencv.js (these are common public CDNs; adjust if you host locally)
  const OPENCV_CDNS = [
    // official doc distro (often available)
    'https://docs.opencv.org/4.x/opencv.js',
    // jsDelivr CDN (may not always host)
    'https://cdn.jsdelivr.net/npm/opencv.js@4.7.0/opencv.js',
    // unpkg fallback
    'https://unpkg.com/opencv.js@4.7.0/opencv.js'
  ];

  // ---------- DOM ----------
  const canvas = document.getElementById('view');
  const dbg = document.getElementById('dbg');
  const enableBtn = document.getElementById('enableBtn');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const exportBtn = document.getElementById('exportBtn');
  const reqLaps = document.getElementById('reqLaps');
  const timerEl = document.getElementById('timer');
  const statusEl = document.getElementById('status');
  const tbody = document.getElementById('tbody');
  const logEl = document.getElementById('log');
  const libStatusEl = document.getElementById('libStatus');
  const libRetryBtn = document.getElementById('libRetryBtn');
  const cooldownInput = document.getElementById('cooldown');
  const detectEveryInput = document.getElementById('detectEvery');
  const tolInput = document.getElementById('tol');

  let ctx = null;

  // ---------- State ----------
  let stream = null, video = null;
  let w = 1280, h = 720, guideY = 0;
  let running = false, counting = false, startTime = 0, timerTick = null;
  let frameCount = 0, framesDrawn = 0;
  const runners = {}; // id -> { laps, last, finishMs, finishStr, done }
  const DEFAULT_COOLDOWN = 2000;

  // OpenCV related
  let cvReady = false;
  let arucoDetector = null; // either ArucoDetector or fallback data
  let arucoDictionary = null;
  let arucoParams = null;

  // Utility log
  const log = (...a) => { console.log(...a); logEl.textContent = (logEl.textContent + '\n' + a.join(' ')).slice(-6000); };

  function setStatus(s){ statusEl.textContent = s; }

  function msToHMS(ms){
    if (ms === undefined || ms === null || ms === '-') return '-';
    const sec = Math.floor(ms/1000);
    const mm = String(Math.floor(sec/60)).padStart(2,'0');
    const ss = String(sec%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  // Table helpers
  function ensureRow(id){
    if (runners[id]) return;
    runners[id] = { laps:0, last:0, finishMs:null, finishStr:'-', done:false };
    const tr = document.createElement('tr');
    tr.id = `r-${id}`;
    tr.innerHTML = `<td>${id}</td><td id="laps-${id}">0</td><td id="fin-${id}">-</td>`;
    tbody.appendChild(tr);
  }
  function updateRow(id){
    document.getElementById(`laps-${id}`).textContent = runners[id].laps;
    document.getElementById(`fin-${id}`).textContent = runners[id].finishStr;
    if (runners[id].done) document.getElementById(`r-${id}`).classList.add('done');
  }

  // Counting helpers
  function getCooldown(){ return Math.max(50, parseInt(cooldownInput.value || DEFAULT_COOLDOWN, 10)); }
  function getDetectEvery(){ return Math.max(1, parseInt(detectEveryInput.value || '2', 10)); }
  function getTol(){ return Math.max(4, parseInt(tolInput.value || '24', 10)); }
  function countLap(id){
    if (!counting) return;
    const now = Date.now();
    const r = runners[id];
    if (r.done) return;
    if (now - r.last < getCooldown()) return;
    r.laps++;
    r.last = now;
    if (r.laps >= parseInt(reqLaps.value, 10)){
      r.done = true;
      r.finishMs = now - startTime;
      r.finishStr = msToHMS(r.finishMs);
    }
    updateRow(id);
    log(`Tag ${id} lap ${r.laps}${r.done ? ' (finished @'+r.finishStr+')' : ''}`);
  }

  // ---------- OpenCV loader (with retries & onRuntimeInitialized) ----------
  function loadScript(url, timeout = 10000){
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = url;
      s.async = true;
      s.crossOrigin = 'anonymous';
      let settled = false;
      s.onload = () => { if (!settled){ settled = true; resolve(); } };
      s.onerror = (e) => { if (!settled){ settled = true; reject(new Error('Failed to load ' + url)); } };
      document.head.appendChild(s);
      setTimeout(() => {
        if (!settled){
          settled = true;
          reject(new Error('Timeout loading ' + url));
        }
      }, timeout);
    });
  }

  async function tryLoadOpenCV(){
    libStatusEl.textContent = 'loading...';
    dbg.style.display = 'none';
    // if already ready
    if (window.cv && window.cv['onRuntimeInitialized'] && cvReady) { libStatusEl.textContent = 'loaded'; return true; }

    for (const url of OPENCV_CDNS){
      try {
        log('Attempting to load OpenCV.js from', url);
        await loadScript(url, 12000);
        // wait for the runtime initialization callback to fire (max wait ~12s)
        const ok = await new Promise((resolve) => {
          const start = Date.now();
          // if cv is already initialized
          if (window.cv && window.cv['onRuntimeInitialized'] && window.cv['ready']) return resolve(true);
          // attach onRuntimeInitialized if available
          if (window.cv) {
            // some builds set cv.onRuntimeInitialized; attach
            window.cv['onRuntimeInitialized'] = () => { resolve(true); };
          }
          // polling fallback
          (function poll(){
            if (window.cv && window.cv['onRuntimeInitialized'] && window.cv['ready']) return resolve(true);
            if (Date.now() - start > 12000) return resolve(false);
            setTimeout(poll, 200);
          })();
        });
        if (!ok){
          log('OpenCV loaded but runtime did not initialize in time for', url);
          continue;
        }
        // runtime initialized
        libStatusEl.textContent = 'loaded';
        cvReady = true;
        log('OpenCV ready from', url);
        // prepare aruco structures (try to create Detector if available)
        tryInitAruco();
        return true;
      } catch (e){
        log('Load failed for', url, e && e.message ? e.message : e);
      }
    }
    libStatusEl.textContent = 'failed';
    dbg.style.display = '';
    dbg.textContent = 'OpenCV.js failed to load. Use Retry and open DevTools Network to inspect errors.';
    return false;
  }

  function tryInitAruco(){
    if (!cv || !cv['aruco']) {
      // Some builds expose aruco under cv.aruco; if not present, detection may still work with lower-level API — we'll check at runtime
      log('cv.aruco is', !!(cv && cv.aruco));
    }
    try {
      // Preferred new API: cv.aruco.ArucoDetector (OpenCV 4.7+)
      if (cv.aruco && typeof cv.aruco.ArucoDetector === 'function') {
        arucoDictionary = new cv.aruco.Dictionary(cv.aruco.DICT_6X6_250);
        arucoParams = new cv.aruco.DetectorParameters();
        arucoDetector = new cv.aruco.ArucoDetector(arucoDictionary, arucoParams);
        log('ArucoDetector created (new API).');
      } else if (cv.aruco && typeof cv.aruco.getPredefinedDictionary === 'function') {
        // older style
        arucoDictionary = cv.aruco.getPredefinedDictionary(cv.aruco.DICT_6X6_250);
        arucoParams = new cv.aruco.DetectorParameters();
        // we will use cv.aruco.detectMarkers(...) in loop
        arucoDetector = null;
        log('Using cv.aruco.getPredefinedDictionary + detectMarkers fallback.');
      } else {
        // If cv.aruco not present, detection won't work
        log('cv.aruco not available in this OpenCV build — ArUco detection may not be supported.');
        arucoDetector = null;
      }
    } catch (e){
      console.warn('Aruco init error', e);
      arucoDetector = null;
    }
  }

  // Kick initial load attempt
  tryLoadOpenCV();

  libRetryBtn.addEventListener('click', async () => {
    libStatusEl.textContent = 'retrying...';
    dbg.style.display = 'none';
    await tryLoadOpenCV();
  });

  // ---------- Camera enabling with drawImage fix ----------
  function createCanvasContextForVideo(videoWidth, videoHeight){
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = '100%';
    canvas.style.height = 'auto';
    canvas.width = Math.max(320, Math.round(videoWidth * dpr));
    canvas.height = Math.max(180, Math.round(videoHeight * dpr));
    ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  async function enableCamera(){
    try {
      // ensure OpenCV loaded (attempt if not)
      if (!cvReady){
        const ok = await tryLoadOpenCV();
        if (!ok){
          alert('OpenCV failed to load. Press "Retry OpenCV Load" and check network console.');
          return;
        }
      }

      // request camera
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: 'environment' }, width: { ideal:1280 }, height:{ ideal:720 } },
        audio: false
      });

      // create a video element that is renderable (not display:none)
      video = document.createElement('video');
      video.autoplay = true;
      video.muted = true;
      video.playsInline = true;
      video.srcObject = stream;
      // keep off-screen but renderable
      video.style.position = 'absolute';
      video.style.left = '-10000px';
      video.style.top = '0';
      video.style.width = '1px';
      video.style.height = '1px';
      video.style.opacity = '0.001';
      document.body.appendChild(video);

      await video.play();
      await new Promise(r => { if (video.readyState >= 2) return r(); video.onloadedmetadata = r; });

      // set canvas to video resolution
      const realW = video.videoWidth || 1280;
      const realH = video.videoHeight || 720;
      createCanvasContextForVideo(realW, realH);
      w = realW; h = realH;
      guideY = Math.round(h * 0.7);

      // ensure aruco prepared
      if (!arucoDictionary) tryInitAruco();
      if (!arucoDictionary) {
        alert('ArUco structures could not be initialized. OpenCV.js build may lack aruco support.');
        setStatus('Aruco missing');
      } else {
        setStatus('Ready (ArUco ready)');
      }

      enableBtn.disabled = true;
      startBtn.disabled = false;
      stopBtn.disabled = false;
      running = true;
      frameCount = 0; framesDrawn = 0;
      requestAnimationFrame(loop);
      log('Camera enabled', `${w}x${h}`);
    } catch (e){
      console.error('Camera error', e);
      alert('Camera error: ' + (e && e.message ? e.message : e));
      setStatus('Camera error');
    }
  }

  function stopCamera(){
    if (stream){
      stream.getTracks().forEach(t => { try { t.stop(); } catch(e){} });
    }
    stream = null;
    if (video){
      try{ video.pause(); video.srcObject = null; video.remove(); }catch(e){}
      video = null;
    }
    running = false;
    setStatus('Camera stopped');
    enableBtn.disabled = false;
    startBtn.disabled = true;
    stopBtn.disabled = true;
  }

  // ---------- Main loop: draw + detect using OpenCV ArUco ----------
  function loop(){
    if (!running) return;

    if (video && video.readyState >= 2){
      try {
        ctx.drawImage(video, 0, 0, w, h);
        framesDrawn++;
      } catch (e){
        console.error('drawImage error', e);
        dbg.style.display = '';
        dbg.textContent = 'drawImage error: ' + (e && e.message ? e.message : e);
      }
    } else {
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,w,h);
    }

    // draw guide line
    ctx.save();
    ctx.strokeStyle = 'red';
    ctx.lineWidth = Math.max(3, (h/240));
    ctx.beginPath();
    ctx.moveTo(0, guideY);
    ctx.lineTo(w, guideY);
    ctx.stroke();
    ctx.restore();

    frameCount++;
    if (cvReady && (frameCount % getDetectEvery() === 0) && video && video.readyState >= 2){
      // Read canvas into cv.Mat
      let src = null, gray = null;
      try {
        src = cv.imread(canvas); // reads canvas into RGBA Mat scaled by DPR transform we set earlier
        gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      } catch (e){
        console.error('cv.imread / cv.cvtColor error', e);
      }

      if (gray){
        try {
          // detection: try modern ArucoDetector if present
          let corners = new cv.MatVector();
          let ids = new cv.Mat();
          if (arucoDetector && typeof arucoDetector.detectMarkers === 'function') {
            // modern API: arucoDetector.detectMarkers(image, corners, ids)
            try {
              arucoDetector.detectMarkers(gray, corners, ids);
            } catch (e) {
              // some builds require different call signature
              try {
                cv.aruco.detectMarkers(gray, arucoDictionary, corners, ids, arucoParams);
              } catch (ee) {
                console.warn('Both detect attempts failed', e, ee);
              }
            }
          } else if (cv.aruco && typeof cv.aruco.detectMarkers === 'function') {
            // fallback API
            try {
              cv.aruco.detectMarkers(gray, arucoDictionary, corners, ids, arucoParams);
            } catch (e) {
              console.warn('cv.aruco.detectMarkers failed', e);
            }
          } else {
            // aruco not available
            dbg.style.display = '';
            dbg.textContent = 'ArUco not available in this OpenCV build.';
          }

          // if we have ids and corners, process them
          if (ids && !ids.empty()){
            // ids is a Mat of shape (N,1) or (N,). corners is MatVector of N Mats each Nx2x? containing corners
            const n = ids.rows || ids.cols || ids.data32S?.length || 0;
            // draw overlays and count
            ctx.save();
            ctx.strokeStyle = 'lime';
            ctx.fillStyle = 'rgba(0,255,0,0.18)';
            ctx.lineWidth = Math.max(2, h/360);
            // Read ids into JS array
            let idArr = [];
            try {
              for (let i=0;i<ids.rows;i++){
                idArr.push(ids.intPtr(i,0)[0]);
              }
            } catch (e){
              // fallback for different shapes
              try {
                const idData = ids.data32S || ids.data32F || ids.data8U;
                for (let i=0;i<idData.length;i++) idArr.push(idData[i]);
              } catch (ee){}
            }

            for (let i=0;i<idArr.length;i++){
              const id = idArr[i];
              try {
                const cornerMat = corners.get(i); // Nx1x2-ish mat
                // cornerMat is typically 4x1x2 or 1x4x2; extract points
                let cx=0, cy=0, pts = [];
                // extract points by reading float data
                if (cornerMat.rows >= 4 && cornerMat.cols >= 1){
                  // iterate rows
                  for (let r=0;r<cornerMat.rows;r++){
                    // each entry has 2 floats
                    const x = cornerMat.floatAt(r,0*2 || 0); // sometimes API differs; we'll read using data32F
                  }
                }
                // safer: convert to typed array by reading data32F and grouping by 2
                const data = cornerMat.data32F || cornerMat.data32F || cornerMat.data32F;
                if (data && data.length >= 8){
                  for (let k=0;k<4;k++){
                    const x = data[k*2];
                    const y = data[k*2+1];
                    pts.push({x,y});
                    cx += x; cy += y;
                  }
                  cx /= 4; cy /= 4;
                } else {
                  // try alternative access using .data32S or .data
                  const dataAlt = cornerMat.data32S || cornerMat.data;
                  if (dataAlt && dataAlt.length >= 8){
                    for (let k=0;k<4;k++){
                      const x = dataAlt[k*2];
                      const y = dataAlt[k*2+1];
                      pts.push({x,y});
                      cx += x; cy += y;
                    }
                    cx /= 4; cy /= 4;
                  } else {
                    // fallback: skip
                    continue;
                  }
                }

                // draw center dot
                ctx.beginPath(); ctx.arc(cx, cy, Math.max(4, h/200), 0, Math.PI*2); ctx.fill();

                // draw polygon
                if (pts.length === 4){
                  ctx.beginPath();
                  ctx.moveTo(pts[0].x, pts[0].y);
                  for (let p=1;p<4;p++) ctx.lineTo(pts[p].x, pts[p].y);
                  ctx.closePath(); ctx.stroke();
                }

                ensureRow(id);
                if (counting && Math.abs(cy - guideY) <= getTol()){
                  countLap(id);
                }

                cornerMat.delete();
              } catch (e){
                console.warn('Corner parse error', e);
              }
            }
            ctx.restore();
          }

          // cleanup
          corners.delete && corners.delete();
          ids.delete && ids.delete();
        } catch (e){
          console.warn('ArUco detect / processing error', e);
        } finally {
          gray.delete && gray.delete();
          src.delete && src.delete();
        }
      } else {
        // cleanup if created partially
        src && src.delete && src.delete();
      }
    }

    if (frameCount > 10 && framesDrawn === 0){
      dbg.style.display = '';
      dbg.textContent = 'No frames drawn — ensure camera permission and that the video element is not display:none.';
    } else if (framesDrawn > 0){
      dbg.style.display = 'none';
    }

    requestAnimationFrame(loop);
  }

  // ---------- Timer ----------
  function startTimer(){
    startTime = Date.now();
    timerEl.textContent = '00:00';
    timerTick = setInterval(() => {
      timerEl.textContent = msToHMS(Date.now() - startTime);
    }, 250);
  }
  function stopTimer(){
    if (timerTick) clearInterval(timerTick);
    timerTick = null;
  }

  // ---------- Start / Stop counting ----------
  function startCounting(){
    if (!cvReady) { alert('OpenCV not ready. Retry loading.'); return; }
    if (!stream) { alert('Enable camera first'); return; }
    if (counting) return;
    counting = true;
    startTimer();
    setStatus('Counting');
    exportBtn.disabled = true;
    log('Counting started ' + new Date().toISOString());
  }

  function stopCounting(){
    if (!counting) return;
    counting = false;
    stopTimer();
    setStatus('Stopped');

    // mark DNF for non-finishers
    const req = parseInt(reqLaps.value, 10);
    for (const id of Object.keys(runners)){
      const r = runners[id];
      if (!r.done || r.laps < req){
        r.finishStr = 'DNF';
        r.finishMs = null;
        updateRow(id);
      }
    }

    exportBtn.disabled = false;
    log('Counting stopped ' + new Date().toISOString());
  }

  // ---------- Export ----------
  function exportCSV(){
    const rows = [['tag_id','laps','finish','finish_ms']];
    for (const id of Object.keys(runners)){
      const r = runners[id];
      rows.push([id, r.laps, r.finishStr || '-', r.finishMs === null ? '' : r.finishMs]);
    }
    const csv = rows.map(r => r.map(cell => {
      if (typeof cell === 'string' && cell.includes(',')) return `"${cell.replace(/"/g,'""')}"`;
      return cell;
    }).join(',')).join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `aruco_laps_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    setStatus('CSV exported');
    log('CSV exported');
  }

  // ---------- Events ----------
  enableBtn.addEventListener('click', enableCamera);
  startBtn.addEventListener('click', startCounting);
  stopBtn.addEventListener('click', stopCounting);
  exportBtn.addEventListener('click', exportCSV);
  libRetryBtn.addEventListener('click', tryLoadOpenCV);

  // stop camera on unload
  window.addEventListener('beforeunload', () => {
    if (stream) stream.getTracks().forEach(t=>t.stop());
  });

  // initial UI
  setStatus('Idle');
  libStatusEl.textContent = 'loading...';
  log('Ready. The app will attempt to load OpenCV.js (ArUco). If loading fails, open DevTools Network tab and retry.');

  </script>
</body>
</html>
