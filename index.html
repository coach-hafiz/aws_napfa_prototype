<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>AprilTag Lap Counter (Mobile – Fixed)</title>
<style>
  :root{ --accent:#015871 }
  *{ box-sizing:border-box }
  body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:#f7f7f7; color:#111 }
  .bar{ position:sticky; top:0; z-index:10; background:#fff; border-bottom:1px solid #e9e9e9; padding:12px; display:flex; flex-wrap:wrap; gap:8px; align-items:center }
  button{ height:44px; min-width:110px; padding:0 12px; font-weight:700; font-size:14px; color:#fff; background:var(--accent); border:0; border-radius:12px }
  button.secondary{ background:#666 }
  input[type=number]{ height:40px; width:90px; padding:0 8px; font-size:14px; border:1px solid #ccc; border-radius:10px; background:#fff }
  input[type=checkbox]{ transform:scale(1.1); margin-left:6px; margin-right:2px }
  .timer{ font-variant-numeric:tabular-nums; font-weight:700; min-width:90px }
  .wrap{ width:100%; max-width:100%; background:#000 }
  canvas#view{ display:block; width:100%; height:auto; touch-action:none }
  .panel{ padding:12px }
  .tbl{ max-height:46vh; overflow:auto; background:#fff; border:1px solid #eee; border-radius:12px }
  table{ width:100%; border-collapse:collapse }
  thead th{ position:sticky; top:0; z-index:1; background:var(--accent); color:#fff; font-weight:700 }
  th,td{ padding:8px; text-align:center; border-bottom:1px solid #f0f0f0; font-size:14px }
  tr.done{ background:#e9f6ec }
  tr.detail{ background:#fffef8; font-size:13px }
  .log{ font-size:12px; color:#444; margin-top:8px; white-space:pre-wrap; max-height:10vh; overflow:auto }
  .small{ font-size:12px; color:#333 }
  .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .muted{ color:#666; font-size:12px }
  .pill{ padding:6px 10px; background:#f0f7fa; border-radius:999px; font-size:12px; color:#014851 }
</style>
</head>
<body>
  <div class="bar">
    <div class="controls">
      <button id="enableBtn">Enable Camera</button>
      <button id="startBtn" class="secondary" disabled>Start</button>
      <button id="stopBtn"   class="secondary" disabled>Stop</button>
      <button id="exportCsvBtn" class="secondary" disabled>Export CSV</button>
      <button id="exportJsonBtn" class="secondary" disabled>Export JSON</button>
      <button id="resetBtn" class="secondary" disabled>Reset</button>
      <div class="pill" id="statusPill">Idle</div>
    </div>

    <div style="margin-left:auto;display:flex;gap:10px;align-items:center">
      <div class="timer" id="timer">00:00</div>
      <label for="req" class="small">Req. Laps</label>
      <input id="req" type="number" value="4" min="1" max="50" inputmode="numeric" />
    </div>
  </div>

  <div style="padding:8px 12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; background:#fff; border-bottom:1px solid #eee">
    <label class="small">Cooldown (ms)</label>
    <input id="cooldownInput" type="number" value="2000" min="200" style="width:110px" />
    <label class="small">Detect every N frames</label>
    <input id="detectEvery" type="number" value="2" min="1" style="width:80px" />
    <label class="small"><input id="autoStop" type="checkbox" /> Auto-stop when all finish</label>
  </div>

  <div class="wrap">
    <canvas id="view"></canvas>
  </div>

  <div class="panel">
    <div class="tbl">
      <table>
        <thead><tr><th>Tag ID</th><th>Laps</th><th>Finish</th><th>Details</th></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
    <div class="log" id="log"></div>
  </div>

  <!-- AprilTag JS (WASM, ImageData API) -->
  <script defer src="https://unpkg.com/apriltag-js@0.1.4/dist/apriltag.min.js"></script>

  <script>
  // ---------- DOM ----------
  const canvas = document.getElementById('view');
  const ctx    = canvas.getContext('2d', { willReadFrequently: true });
  const tbody  = document.getElementById('tbody');
  const logEl  = document.getElementById('log');
  const timerEl= document.getElementById('timer');
  const reqEl  = document.getElementById('req');
  const enableBtn = document.getElementById('enableBtn');
  const startBtn  = document.getElementById('startBtn');
  const stopBtn   = document.getElementById('stopBtn');
  const exportCsvBtn = document.getElementById('exportCsvBtn');
  const exportJsonBtn = document.getElementById('exportJsonBtn');
  const resetBtn = document.getElementById('resetBtn');
  const cooldownInput = document.getElementById('cooldownInput');
  const detectEveryInput = document.getElementById('detectEvery');
  const autoStopInput = document.getElementById('autoStop');
  const statusPill = document.getElementById('statusPill');

  // ---------- State ----------
  let stream=null, video=null;
  let w=0, h=0, guideY=0;
  let running=false, counting=false, startTime=0, tick=null;
  let detector=null; // apriltag-js detector
  const runners = {}; // id -> {laps, done, last, finish, lapTimes: [msSinceStart]}
  let frameCount = 0;

  const log = (...a)=>{ console.log(...a); logEl.textContent = (logEl.textContent + '\n' + a.join(' ')).trim().slice(-4000) };

  function setStatus(s){
    statusPill.textContent = s;
  }

  function msToHMS(ms){
    const totalSec = Math.floor(ms/1000);
    const mm = String(Math.floor(totalSec/60)).padStart(2,'0');
    const ss = String(totalSec%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  function hmsSince(t0){
    return msToHMS(Date.now() - t0);
  }

  // ---------- Runner table ----------
  function ensureRow(id){
    if (runners[id]) return;
    runners[id] = { laps:0, done:false, last:0, finish:'-', lapTimes: [] };
    const tr = document.createElement('tr');
    tr.id = `r-${id}`;
    tr.innerHTML = `<td>${id}</td><td id="laps-${id}">0</td><td id="fin-${id}">-</td><td><button data-id="${id}" class="detailBtn">View</button></td>`;
    tbody.appendChild(tr);

    // detail row (hidden initially)
    const dtr = document.createElement('tr');
    dtr.id = `d-${id}`;
    dtr.className = 'detail';
    dtr.style.display = 'none';
    const td = document.createElement('td');
    td.colSpan = 4;
    td.id = `detail-${id}`;
    td.innerHTML = `<div class="small">No laps yet</div>`;
    dtr.appendChild(td);
    tbody.appendChild(dtr);

    tr.querySelector('.detailBtn').addEventListener('click', (e)=>{
      const did = document.getElementById(`d-${id}`);
      did.style.display = (did.style.display === 'none') ? '' : 'none';
    });

    // Enable export/reset when first row created
    exportCsvBtn.disabled = false;
    exportJsonBtn.disabled = false;
    resetBtn.disabled = false;
  }

  function updateRow(id){
    document.getElementById(`laps-${id}`).textContent = runners[id].laps;
    document.getElementById(`fin-${id}`).textContent  = runners[id].finish;
    const detail = document.getElementById(`detail-${id}`);
    if (!detail) return;
    if (runners[id].lapTimes.length === 0){
      detail.innerHTML = `<div class="small">No laps yet</div>`;
      return;
    }
    // build table of lap times
    let html = `<div class="small">Laps: ${runners[id].laps} ${runners[id].done ? ' (Finished)' : ''}</div><table style="width:100%;margin-top:6px;border-collapse:collapse">`;
    html += `<thead><tr><th>#</th><th>Time (mm:ss)</th><th>Interval (s)</th></tr></thead><tbody>`;
    for (let i=0;i<runners[id].lapTimes.length;i++){
      const t = runners[id].lapTimes[i];
      const prev = (i>0) ? runners[id].lapTimes[i-1] : 0;
      const interval = ((t - prev)/1000).toFixed(2);
      html += `<tr><td style="padding:6px;text-align:center">${i+1}</td><td style="padding:6px;text-align:center">${msToHMS(t)}</td><td style="padding:6px;text-align:center">${interval}</td></tr>`;
    }
    html += `</tbody></table>`;
    detail.innerHTML = html;
  }

  function markDone(id){
    document.getElementById(`r-${id}`)?.classList.add('done');
  }

  // ---------- Counting ----------
  function getCooldown(){ return Math.max(50, parseInt(cooldownInput.value || '2000', 10)); }
  function getDetectEvery(){ return Math.max(1, parseInt(detectEveryInput.value || '2', 10)); }

  function countLap(id){
    if (!counting) return;
    const now = Date.now();
    const r = runners[id];
    const req = parseInt(reqEl.value||'4',10);
    if (r.done) return;
    if (now - r.last < getCooldown()) return;
    r.laps++;
    r.last = now;
    const sinceStart = now - startTime;
    r.lapTimes.push(sinceStart);
    if (r.laps >= req){
      r.done = true;
      r.finish = msToHMS(sinceStart);
      markDone(id);
    }
    updateRow(id);
    log(`Tag ${id} lap ${r.laps} @ ${msToHMS(sinceStart)} (${(sinceStart/1000).toFixed(2)}s)`);

    // check auto-stop if enabled
    if (autoStopInput.checked){
      if (allFinished()) {
        stopCounting();
        setStatus('All finished (auto-stopped)');
      }
    }
  }

  function allFinished(){
    const ids = Object.keys(runners);
    if (ids.length === 0) return false;
    return ids.every(id => runners[id].done);
  }

  // ---------- Camera (explicit user gesture) ----------
  async function enableCamera(){
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        audio:false,
        video:{
          facingMode:{ ideal:'environment' },
          width:{ ideal:1280 }, height:{ ideal:720 }
        }
      });
      video = document.createElement('video');
      video.srcObject = stream;
      video.playsInline = true; // iOS
      video.muted = true;       // iOS autoplay requirement
      await video.play();
      await new Promise(r=> video.onloadedmetadata = r);

      // Size canvas to video
      w = video.videoWidth  || 1280;
      h = video.videoHeight || 720;
      canvas.width = w; canvas.height = h;
      guideY = Math.round(h*0.7);

      // Init detector
      if (!window.apriltag || typeof window.apriltag.Detector !== 'function'){
        log('❌ apriltag-js not loaded yet. Check network / CDN.');
        alert('AprilTag library failed to load. Try reload with network.');
        return;
      }
      detector = new window.apriltag.Detector({ families: ['tag36h11'] });
      log('✅ Camera & detector ready:', w+'x'+h);

      // UI states
      enableBtn.disabled = true;
      startBtn.disabled = false;
      stopBtn.disabled = false;
      setStatus('Ready');

      // Start render loop (video + red line visible immediately)
      running = true;
      requestAnimationFrame(loop);
    }catch(e){
      console.error(e);
      alert('Camera error: ' + (e.message||e));
      log('Camera error:', e.message||e);
    }
  }

  // stop camera stream & tracks
  function stopCamera(){
    if (stream){
      for (const track of stream.getTracks()){
        try{ track.stop(); }catch(e){}
      }
    }
    stream = null;
    video = null;
    running = false;
    enableBtn.disabled = false;
    startBtn.disabled = true;
    stopBtn.disabled = true;
    setStatus('Camera stopped');
  }

  // ---------- Main loop ----------
  function loop(){
    if (!running) return;

    // Draw video frame on canvas
    if (video && video.readyState >= 2) {
      ctx.drawImage(video, 0, 0, w, h);
    } else {
      ctx.clearRect(0,0,w,h);
    }

    // Red guide line (always visible)
    ctx.strokeStyle = 'red';
    ctx.lineWidth = Math.max(3, h/240);
    ctx.beginPath();
    ctx.moveTo(0, guideY);
    ctx.lineTo(w, guideY);
    ctx.stroke();

    // Detection (throttled)
    frameCount++;
    const DETECT_EVERY = getDetectEvery();
    if (detector && (frameCount % DETECT_EVERY === 0) && video && video.readyState >=2) {
      const frame = ctx.getImageData(0, 0, w, h); // full frame
      let dets = [];
      try{
        dets = detector.detect(frame) || [];
      }catch(e){
        log('Detect error:', e.message||e);
      }

      if (dets.length){
        ctx.save();
        ctx.strokeStyle='lime'; ctx.lineWidth = Math.max(2, h/360);
        ctx.fillStyle='rgba(0,128,0,0.25)';
        for (const d of dets){
          const cs = d.corners || d.c || [];
          // draw center dot & light box
          let cx=0, cy=0;
          for (const c of cs){ cx += c.x; cy += c.y; }
          const n = Math.max(1, cs.length);
          cx/=n; cy/=n;

          // center dot
          ctx.beginPath(); ctx.arc(cx, cy, Math.max(4, h/200), 0, Math.PI*2); ctx.fill();

          // quick box
          if (cs.length===4){
            ctx.beginPath();
            ctx.moveTo(cs[0].x, cs[0].y);
            for(let i=1;i<4;i++) ctx.lineTo(cs[i].x, cs[i].y);
            ctx.closePath(); ctx.stroke();
          }

          const id = (d.id ?? d.tag_id ?? -1);
          ensureRow(id);
          if (counting && Math.abs(cy - guideY) < Math.max(16, h/60)) {
            countLap(id);
          }
        }
        ctx.restore();
      }
    }

    requestAnimationFrame(loop);
  }

  // ---------- Timer ----------
  function startTimer(){
    startTime = Date.now();
    timerEl.textContent = '00:00';
    tick = setInterval(()=>{ timerEl.textContent = hmsSince(startTime); }, 1000);
  }
  function stopTimer(){
    clearInterval(tick); tick = null;
  }

  // ---------- Start / Stop counting ----------
  function startCounting(){
    if (!stream || !detector) { alert('Enable Camera first.'); return; }
    if (counting) return;
    counting = true; startTimer();
    setStatus('Counting');
    log('Counting started at', new Date().toISOString());
  }

  function stopCounting(){
    if (!counting) return;
    counting = false; stopTimer();
    setStatus('Paused');
    log('Counting stopped at', new Date().toISOString());
  }

  // ---------- Export ----------
  function buildExportData(){
    // returns array of objects: { tag_id, lap_no, lap_ms, lap_hms, finished, finish_hms }
    const data = [];
    for (const id of Object.keys(runners)){
      const r = runners[id];
      for (let i=0;i<r.lapTimes.length;i++){
        const ms = r.lapTimes[i];
        data.push({
          tag_id: id,
          lap_no: i+1,
          lap_ms: ms,
          lap_hms: msToHMS(ms),
          finished: r.done && (i+1 === r.lapTimes.length && r.laps >= parseInt(reqEl.value||'4',10)),
          finish_hms: r.finish
        });
      }
      // if no laps, still include a row
      if (r.lapTimes.length === 0){
        data.push({
          tag_id: id,
          lap_no: 0,
          lap_ms: 0,
          lap_hms: '-',
          finished: r.done,
          finish_hms: r.finish
        });
      }
    }
    return data;
  }

  function exportCSV(){
    const rows = buildExportData();
    const cols = ['tag_id','lap_no','lap_ms','lap_hms','finished','finish_hms'];
    let csv = cols.join(',') + '\n';
    for (const r of rows){
      csv += cols.map(c => {
        const v = r[c];
        if (typeof v === 'string' && v.includes(',')) return `"${v.replace(/"/g,'""')}"`;
        return v;
      }).join(',') + '\n';
    }
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `laps_${new Date().toISOString()}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    setStatus('Exported CSV');
  }

  function exportJSON(){
    const rows = buildExportData();
    const blob = new Blob([JSON.stringify(rows, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `laps_${new Date().toISOString()}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    setStatus('Exported JSON');
  }

  function resetAll(){
    // clear table and state but keep camera open
    for (const id of Object.keys(runners)){
      const tr = document.getElementById(`r-${id}`);
      const dtr = document.getElementById(`d-${id}`);
      if (tr) tr.remove();
      if (dtr) dtr.remove();
    }
    for (const k in runners) delete runners[k];
    exportCsvBtn.disabled = true;
    exportJsonBtn.disabled = true;
    resetBtn.disabled = true;
    stopCounting();
    timerEl.textContent = '00:00';
    setStatus('Reset');
    log('State reset');
  }

  // ---------- Events ----------
  enableBtn.addEventListener('click', enableCamera);
  startBtn.addEventListener('click', startCounting);
  stopBtn.addEventListener('click', stopCounting);
  exportCsvBtn.addEventListener('click', exportCSV);
  exportJsonBtn.addEventListener('click', exportJSON);
  resetBtn.addEventListener('click', ()=>{
    if (!confirm('Reset all recorded laps?')) return;
    resetAll();
  });

  // ---------- Orientation / resize ----------
  window.addEventListener('orientationchange', ()=>{
    setTimeout(()=>{
      if (!video) return;
      w = video.videoWidth; h = video.videoHeight;
      if (w && h){ canvas.width=w; canvas.height=h; guideY=Math.round(h*0.7); }
    }, 400);
  });

  // stop camera on page unload to release device
  window.addEventListener('beforeunload', ()=>{
    stopCamera();
  });

  // expose safe stop for manual use
  window.stopCamera = stopCamera;

  // initial UI
  setStatus('Idle');
  log('Page loaded. Click "Enable Camera" to begin.');

  </script>
</body>
</html>
