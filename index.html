<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>TopCodes Lap Counter</title>
<style>
:root{
  --accent:#015871;
  --bg:#f7f7f7;
  --line:red;
}
*{ box-sizing:border-box }
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  background:var(--bg);
  color:#111;
}

.app{ display:grid; min-height:100vh; }

/* Portrait: make camera view BIGGER */
@media (orientation:portrait){
  .app{
    grid-template-rows: 62vh 1fr;  /* was 45vh */
    grid-template-columns: 1fr;
    grid-template-areas:
      "top"
      "bottom";
  }
  .top{ grid-area: top; }
  .bottom{ grid-area: bottom; }
}

/* Landscape: keep split view */
@media (orientation:landscape){
  .app{
    grid-template-columns: 1.15fr 0.85fr; /* give video a bit more */
    grid-template-rows: 100vh;
    grid-template-areas:
      "left right";
  }
  .top{ grid-area: left; height:100vh; }
  .bottom{ grid-area: right; height:100vh; }
}

.top{
  position:relative;
  background:#000;
  overflow:hidden;
}

#view{
  width:100%;
  height:100%;
  display:block;
  background:#000;
  touch-action:none;
}

/* Controls overlay */
.controls{
  position:absolute;
  left:0; right:0; top:0;
  z-index:20;
  display:flex;
  flex-direction:column;
  gap:4px;
  padding:8px;
  background:linear-gradient(
    180deg,
    rgba(255,255,255,0.95) 0%,
    rgba(255,255,255,0.80) 80%,
    rgba(255,255,255,0) 100%
  );
  border-bottom:1px solid rgba(0,0,0,0.06);
}

.controls-row{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
  width:100%;
}

button{
  background:var(--accent);
  color:#fff;
  border:0;
  border-radius:10px;
  font-weight:700;
  padding:10px 12px;
  cursor:pointer;
}
button.secondary{ background:#666 }
button:disabled{ opacity:0.5; cursor:default }

select,input[type=number]{
  height:42px;
  padding:0 10px;
  border-radius:10px;
  border:1px solid #ccc;
  background:#fff;
  font-weight:600;
}

.timer{
  font-variant-numeric:tabular-nums;
  font-weight:700;
  min-width:78px;
}
.spacer{ flex:1 1 auto }

.bottom{
  display:grid;
  grid-template-rows: auto 1fr auto;
  gap:8px;
  padding:10px;
  min-height:0;
}
.status{
  font-size:13px;
  color:#333;
  white-space:pre-wrap;
  background:#fff;
  border:1px solid #eee;
  border-radius:10px;
  padding:8px;
}
.tableWrap{
  min-height:0;
  background:#fff;
  border:1px solid #eee;
  border-radius:10px;
  overflow:auto;
}
table{
  width:100%;
  border-collapse:collapse;
  font-size:14px;
}
thead th{
  position:sticky;
  top:0;
  background:var(--accent);
  color:#fff;
  padding:8px;
  z-index:1;
}
td,th{
  padding:8px;
  border-bottom:1px solid #f0f0f0;
  text-align:center;
}
tr.done{ background:#e9f6ec }

.footerBar{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
  font-size:12px;
  color:#444;
}

/* Small screens */
@media (max-width:420px){
  button{ padding:8px 10px }
  .timer{ min-width:66px }
  select,input[type=number]{ height:38px }
}
</style>
</head>
<body>
<div class="app">
  <section class="top">
    <canvas id="view" aria-label="Camera view with overlay and start line"></canvas>

    <div class="controls">
      <div class="controls-row">
        <button id="enableBtn">Enable Camera</button>
        <button id="disableBtn" class="secondary" disabled>Disable Cam</button>

        <button id="swapBtn" class="secondary" disabled>Switch: Back</button>

        <button id="startBtn" class="secondary" disabled>Start</button>
        <button id="stopBtn"  class="secondary" disabled>Stop</button>
        <div class="timer" id="timer">00:00</div>

        <button id="exportBtn" class="secondary" disabled>Export CSV</button>
        <button id="summaryBtn" class="secondary" disabled>Detailed Summary</button>

        <span class="spacer"></span>

        <span style="font-size:11px;color:#555">
          Aim TopCodes so they cross the red line.
        </span>
      </div>

      <div class="controls-row">
        <label for="lapsSel" style="font-size:12px;color:#333">Laps</label>
        <select id="lapsSel" aria-label="Number of laps"></select>

        <label for="distanceInput" style="font-size:12px;color:#333">Run Distance (m)</label>
        <input id="distanceInput" type="number" min="100" step="10" value="1600"
               aria-label="Total run distance in metres" />

        <span id="lapInfo" style="font-size:12px;color:#333;"></span>
      </div>
    </div>
  </section>

  <section class="bottom">
    <div class="status" id="status">Idle. Tap "Enable Camera".</div>
    <div class="tableWrap">
      <table>
        <thead>
        <tr>
          <th>Runner ID</th>
          <th>Laps Left</th>
          <th>Finish</th>
          <th>Splits (mm:ss, …)</th>
        </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
    <div class="footerBar">
      • Use printed TopCodes (IDs 1–20 via mapping) • Good lighting improves scans • Tags can be angled, not perfectly flat
    </div>
  </section>
</div>

<!-- TopCodes library -->
<script src="https://cdn.jsdelivr.net/gh/TIDAL-Lab/TopCodes@master/javascript/topcodes.js"></script>

<script>
(function(){
  var canvas   = document.getElementById('view');
  var ctx      = canvas.getContext('2d', { willReadFrequently:true });

  var statusEl  = document.getElementById('status');
  var tbody     = document.getElementById('tbody');
  var timerEl   = document.getElementById('timer');

  var enableBtn = document.getElementById('enableBtn');
  var disableBtn= document.getElementById('disableBtn');
  var swapBtn   = document.getElementById('swapBtn');

  var startBtn  = document.getElementById('startBtn');
  var stopBtn   = document.getElementById('stopBtn');
  var exportBtn = document.getElementById('exportBtn');
  var summaryBtn= document.getElementById('summaryBtn');

  var lapsSel   = document.getElementById('lapsSel');
  var distanceInput = document.getElementById('distanceInput');
  var lapInfoEl = document.getElementById('lapInfo');

  var cameraActive = false;

  // Facing mode control
  // "environment" = back, "user" = front
  var facingMode = "environment";
  function updateSwapLabel(){
    swapBtn.textContent = "Switch: " + (facingMode === "environment" ? "Back" : "Front");
  }
  updateSwapLabel();

  var runDistanceMeters = parseFloat(distanceInput.value) || 1600;

  // Populate laps 1..20 (default 4)
  for (var i=1;i<=20;i++){
    var opt=document.createElement('option');
    opt.value=i;
    opt.textContent=i;
    if(i===4) opt.selected=true;
    lapsSel.appendChild(opt);
  }

  function setStatus(msg){
    statusEl.textContent = msg;
    console.log(msg);
  }

  function updateLapInfo(){
    var laps = parseInt(lapsSel.value,10) || 0;
    if (!laps || !runDistanceMeters){
      lapInfoEl.textContent = '';
      return;
    }
    var per = runDistanceMeters / laps;
    var perStr = Number.isInteger(per) ? per.toString() : per.toFixed(1);
    lapInfoEl.textContent = '≈ ' + perStr + ' m per lap';
  }

  distanceInput.addEventListener('change', function(){
    var v = parseFloat(distanceInput.value);
    if (!isFinite(v) || v <= 0){
      v = 1600;
      distanceInput.value = '1600';
    }
    runDistanceMeters = v;
    setStatus('Run distance set to ' + runDistanceMeters + ' m.');
    updateLapInfo();
  });

  lapsSel.addEventListener('change', updateLapInfo);

  // TopCode -> Runner ID mapping (A)
  var TOPCODE_MAP = {
    31:1,  47:2,  55:3,  59:4,  61:5,
    79:6,  87:7,  91:8,  93:9,  103:10,
    107:11,109:12,115:13,117:14,121:15,
    143:16,151:17,155:18,157:19,167:20
  };
  function mapCode(raw){
    return TOPCODE_MAP.hasOwnProperty(raw) ? TOPCODE_MAP[raw] : null;
  }

  function msToMMSS(ms){
    var s = Math.floor(ms/1000);
    var m = Math.floor(s/60);
    var ss= s % 60;
    return (m<10?'0':'')+m + ':' + (ss<10?'0':'')+ss;
  }

  function colorForRemaining(rem){
    if (rem === 20 || rem === 14 || rem === 9 || rem === 4) return '#40E0D0';
    if (rem === 19 || rem === 13 || rem === 8 || rem === 3) return '#4CAF50';
    if (rem === 18 || rem === 12 || rem === 7 || rem === 2) return '#9C27B0';
    if (rem === 17)                                        return '#CDDC39';
    if (rem === 16 || rem === 11 || rem === 6)             return '#2196F3';
    if (rem === 15 || rem === 10 || rem === 5)             return '#FF9800';
    if (rem === 1)                                         return '#F44336';
    if (rem <= 0)                                          return '#9E9E9E';
    return '#EEEEEE';
  }

  // State
  var counting   = false;
  var startTime  = 0;
  var timerTick  = null;
  var lineY      = null;
  var COOLDOWN   = 1200;

  // runners[id] = { laps:[], lastTs, finished, totalLaps, lastSide }
  var runners    = {};

  function ensureRunner(id){
    var key = String(id);
    if (!runners[key]){
      var total = parseInt(lapsSel.value,10);
      runners[key] = { laps:[], lastTs:0, finished:false, totalLaps: total, lastSide: null };

      var tr = document.createElement('tr');
      tr.id = 'r-'+key;
      tr.innerHTML =
        '<td>'+id+'</td>'+
        '<td id="laps-'+key+'">'+total+'</td>'+
        '<td id="fin-'+key+'">-</td>'+
        '<td id="splits-'+key+'">-</td>';
      tbody.appendChild(tr);
    }
  }

  function updateRunnerRow(id){
    var key = String(id);
    var r = runners[key];
    if (!r) return;

    var lapsDone  = r.laps.length;
    var remaining = r.totalLaps - lapsDone;
    if (remaining < 0) remaining = 0;

    var lapsCell   = document.getElementById('laps-'+key);
    var finCell    = document.getElementById('fin-'+key);
    var splitsCell = document.getElementById('splits-'+key);

    if (lapsCell){
      lapsCell.textContent = remaining;
      var c = colorForRemaining(remaining);
      lapsCell.style.backgroundColor = c;
      lapsCell.style.color = (remaining <= 1) ? '#fff' : '#000';
    }

    if (finCell){
      finCell.textContent = lapsDone ? msToMMSS(r.laps[lapsDone-1]) : '-';
      if (r.finished && remaining === 0) finCell.style.fontWeight = '700';
    }

    if (splitsCell){
      if (lapsDone){
        var parts = [];
        for (var i=0;i<r.laps.length;i++) parts.push(msToMMSS(r.laps[i]));
        splitsCell.textContent = parts.join(' | ');
      } else {
        splitsCell.textContent = '-';
      }
    }

    if (r.finished){
      var row = document.getElementById('r-'+key);
      if (row) row.classList.add('done');
    }
  }

  function countLap(id){
    var key = String(id);
    var r = runners[key];
    if (!r) return;

    var now = Date.now();
    if (r.finished) return;
    if (now - r.lastTs < COOLDOWN) return;

    r.laps.push(now - startTime);
    r.lastTs = now;

    if (r.laps.length >= r.totalLaps) r.finished = true;

    updateRunnerRow(id);

    var rem = r.totalLaps - r.laps.length;
    if (rem < 0) rem = 0;
    setStatus('Runner '+id+' → laps left: '+rem+(r.finished ? ' (Finished)' : ''));
  }

  function startTimer(){
    startTime = Date.now();
    timerEl.textContent = '00:00';
    timerTick = setInterval(function(){
      timerEl.textContent = msToMMSS(Date.now()-startTime);
    }, 1000);
  }

  function stopTimer(){
    if (timerTick){
      clearInterval(timerTick);
      timerTick = null;
    }
  }

  /**
   * IMPORTANT: TopCodes.startVideoScan() uses the canvas element's WIDTH/HEIGHT ATTRIBUTES
   * to set camera constraints. So we must keep those attributes in sync with our layout.
   */
  function resizeCanvas(){
    var rect = canvas.getBoundingClientRect();
    if (rect.width <= 0 || rect.height <= 0) return;

    var dpr = window.devicePixelRatio || 1;

    // Use device pixels for detection clarity, but cap to avoid super heavy loads.
    // (Still usually much sharper than CSS-only sizing.)
    var targetW = Math.max(1, Math.round(rect.width * dpr));
    var targetH = Math.max(1, Math.round(rect.height * dpr));

    // Optional cap (prevents requesting 4K on some devices)
    var MAX_W = 1920;
    if (targetW > MAX_W){
      var scale = MAX_W / targetW;
      targetW = Math.round(targetW * scale);
      targetH = Math.round(targetH * scale);
    }

    if (canvas.width !== targetW || canvas.height !== targetH){
      canvas.width  = targetW;
      canvas.height = targetH;

      // Keep ATTRIBUTES aligned (TopCodes reads these)
      canvas.setAttribute('width', String(targetW));
      canvas.setAttribute('height', String(targetH));
    }
  }

  // ===== Patch TopCodes camera constraints to support front/back switching =====
  // (We override startVideoScan to include facingMode while keeping original behavior.)
  function patchTopCodesForFacingMode(){
    if (!window.TopCodes || !TopCodes.startVideoScan) return;

    if (TopCodes.__patchedFacingMode) return;
    TopCodes.__patchedFacingMode = true;

    var originalStartVideoScan = TopCodes.startVideoScan;

    TopCodes.startVideoScan = function(canvasId){
      // initialize scanner if needed (same as library)
      if (!(canvasId in TopCodes._mediaStreams)) {
        // topcodes_initVideoScanner is global inside library
        if (typeof topcodes_initVideoScanner === 'function') topcodes_initVideoScanner(canvasId);
      }

      var canvasEl = document.querySelector("#" + canvasId);
      var videoEl  = document.querySelector("#" + canvasId + "-video");
      if (!canvasEl || !videoEl || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        try { originalStartVideoScan(canvasId); } catch(e){}
        return;
      }

      var vw = parseInt(canvasEl.getAttribute('width'), 10);
      var vh = parseInt(canvasEl.getAttribute('height'), 10);

      // If width/height are missing, fall back to original (but we try to keep them set)
      if (!isFinite(vw) || !isFinite(vh) || vw <= 0 || vh <= 0){
        try { originalStartVideoScan(canvasId); } catch(e){}
        return;
      }

      // Stop any existing stream for this canvasId first (prevents "NotReadableError" on some devices)
      if (TopCodes._mediaStreams[canvasId]) {
        try {
          TopCodes.stopVideoScan(canvasId);
        } catch(e){}
      }

      // Build constraints: prefer facingMode, but keep requested resolution.
      var constraints = {
        audio: false,
        video: {
          width:  { ideal: vw },
          height: { ideal: vh },
          facingMode: { ideal: facingMode }   // <-- key addition
        }
      };

      navigator.mediaDevices.getUserMedia(constraints)
        .then(function(mediaStream){
          videoEl.srcObject = mediaStream;
          TopCodes._mediaStreams[canvasId] = mediaStream;

          // iOS/Safari friendliness
          videoEl.playsInline = true;
          videoEl.muted = true;

          var p = videoEl.play();
          if (p && typeof p.catch === 'function') p.catch(function(){});
        })
        .catch(function(err){
          console.log("getUserMedia failed with facingMode, retrying without facingMode:", err);

          // Fallback: remove facingMode (some devices/browsers ignore or error)
          var fallback = {
            audio: false,
            video: {
              width:  { ideal: vw },
              height: { ideal: vh }
            }
          };

          navigator.mediaDevices.getUserMedia(fallback)
            .then(function(mediaStream){
              videoEl.srcObject = mediaStream;
              TopCodes._mediaStreams[canvasId] = mediaStream;
              videoEl.playsInline = true;
              videoEl.muted = true;

              var p2 = videoEl.play();
              if (p2 && typeof p2.catch === 'function') p2.catch(function(){});
            })
            .catch(function(err2){
              console.error("Camera error:", err2);
              setStatus('Camera error: ' + (err2.message || err2) + '. Check permissions and HTTPS/localhost.');
              enableBtn.disabled = false;
              disableBtn.disabled = true;
              swapBtn.disabled = true;
              startBtn.disabled = true;
              cameraActive = false;
            });
        });
    };
  }

  // ===== TopCodes frame callback =====
  function handleFrame(jsonString){
    var data;
    try{ data = JSON.parse(jsonString); }catch(e){ return; }

    var tcodes = data.topcodes || [];
    var w = canvas.width  || 640;
    var h = canvas.height || 480;

    lineY = Math.round(h * 0.5);

    // Deadband around line to avoid jitter (in PIXELS of the canvas)
    var deadband = Math.max(16, Math.round(h * 0.10));

    // Draw red line overlay
    ctx.save();
    var lineColor = getComputedStyle(document.documentElement).getPropertyValue('--line') || 'red';
    ctx.strokeStyle = (lineColor || 'red').trim();
    ctx.lineWidth   = Math.max(3, h/220);
    ctx.beginPath();
    ctx.moveTo(0, lineY);
    ctx.lineTo(w, lineY);
    ctx.stroke();
    ctx.restore();

    if (!counting) return;

    for (var i=0;i<tcodes.length;i++){
      var tc = tcodes[i];
      var runnerID = mapCode(tc.code);
      if (!runnerID) continue;

      ensureRunner(runnerID);
      var key = String(runnerID);
      var r = runners[key];
      if (!r || r.finished) continue;

      // Tag centre in canvas pixel coords
      var cy = tc.y;

      // side: -1 above, +1 below, 0 within deadband
      var dy = cy - lineY;
      var side = 0;
      if (dy < -deadband) side = -1;
      else if (dy > deadband) side = +1;

      // Count only on a clear crossing from above -> below
      if (r.lastSide === -1 && side === +1){
        countLap(runnerID);
      }

      // Update lastSide only when clearly outside deadband
      if (side !== 0) r.lastSide = side;
    }
  }

  function stopCamera(){
    if (!cameraActive) return;
    try { TopCodes.stopVideoScan('view'); } catch(e){}
    cameraActive = false;

    enableBtn.disabled  = false;
    disableBtn.disabled = true;
    swapBtn.disabled    = true;
    startBtn.disabled   = true;
    stopBtn.disabled    = true;

    setStatus('Camera stopped. You can re-enable it again.');
  }

  function startCamera(){
    if (cameraActive) return;

    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
      setStatus('Error: Camera API not supported. Use HTTPS or localhost.');
      return;
    }

    resizeCanvas();
    patchTopCodesForFacingMode();

    try{
      // Use explicit start (not toggle) for predictability
      TopCodes.startVideoScan('view');
      TopCodes.setVideoFrameCallback('view', handleFrame);

      cameraActive = true;

      enableBtn.disabled  = true;
      disableBtn.disabled = false;
      swapBtn.disabled    = false;
      startBtn.disabled   = false;
      stopBtn.disabled    = true;
      exportBtn.disabled  = true;
      summaryBtn.disabled = true;

      setStatus('Camera active (' + (facingMode === 'environment' ? 'Back' : 'Front') + '). Aim TopCodes so they cross the red line. Tap "Start" to begin.');
    }catch(e){
      console.error(e);
      setStatus('Camera error: ' + (e.message || e) + '. Make sure permissions are granted.');
      enableBtn.disabled = false;
      disableBtn.disabled = true;
      swapBtn.disabled = true;
      startBtn.disabled = true;
      cameraActive = false;
    }
  }

  function restartCamera(){
    if (!cameraActive) return;
    // Stop then start (needed to switch cameras)
    try { TopCodes.stopVideoScan('view'); } catch(e){}
    cameraActive = false;
    startCamera();
  }

  // ===== Buttons =====
  enableBtn.addEventListener('click', function(){
    if (cameraActive) { setStatus('Camera already active.'); return; }
    startCamera();
  });

  disableBtn.addEventListener('click', stopCamera);

  swapBtn.addEventListener('click', function(){
    facingMode = (facingMode === 'environment') ? 'user' : 'environment';
    updateSwapLabel();
    if (cameraActive){
      setStatus('Switching camera…');
      restartCamera();
    }
  });

  startBtn.addEventListener('click', function(){
    if (counting) return;

    // Lock config during run
    lapsSel.disabled = true;
    distanceInput.disabled = true;

    // reset runners and table
    runners = {};
    while (tbody.firstChild) tbody.removeChild(tbody.firstChild);

    counting = true;
    startTimer();

    startBtn.disabled  = true;
    stopBtn.disabled   = false;
    exportBtn.disabled = true;
    summaryBtn.disabled= true;

    setStatus('Counting… TopCodes must CROSS the line (above → below) to reduce laps left.');
  });

  stopBtn.addEventListener('click', function(){
    if (!counting) return;
    counting = false;
    stopTimer();

    // Unlock config after run
    lapsSel.disabled = false;
    distanceInput.disabled = false;

    // Mark unfinished as DNF
    for (var id in runners){
      if (runners.hasOwnProperty(id)){
        var r = runners[id];
        if (!r.finished){
          var finCell = document.getElementById('fin-'+id);
          if (finCell) finCell.textContent = 'DNF';
        }
      }
    }

    startBtn.disabled  = false;
    stopBtn.disabled   = true;
    exportBtn.disabled = Object.keys(runners).length === 0;
    summaryBtn.disabled= Object.keys(runners).length === 0;

    setStatus('Stopped. You can export CSV or view Detailed Summary now.');
  });

  exportBtn.addEventListener('click', function(){
    var ids = Object.keys(runners).sort(function(a,b){ return Number(a)-Number(b); });
    if (!ids.length){ setStatus('No data to export.'); return; }

    var maxLaps = 0;
    for (var idx=0; idx<ids.length; idx++){
      var r = runners[ids[idx]];
      if (r.laps.length > maxLaps) maxLaps = r.laps.length;
    }

    var rows = [];
    var header = ['Runner ID','Total Laps','Run Distance (m)','Total Distance (m)','Finish','Pace (min/km)'];
    for (var j=1;j<=maxLaps;j++) header.push('Lap '+j+' (mm:ss)');
    rows.push(header);

    var totalRunMeters = runDistanceMeters;

    for (idx=0; idx<ids.length; idx++){
      var id = ids[idx];
      var rr = runners[id];
      var total  = rr.totalLaps;
      var lapsDone = rr.laps.length;
      var finishMs = lapsDone ? rr.laps[lapsDone-1] : NaN;
      var finishStr = lapsDone ? msToMMSS(finishMs) : 'DNF';

      var totalDist = totalRunMeters;
      var paceStrVal = '';
      if (lapsDone){
        var totalSec = finishMs/1000;
        var paceSecPerKm = totalSec / (totalDist/1000);
        var paceMin = Math.floor(paceSecPerKm / 60);
        var paceSec = Math.round(paceSecPerKm % 60);
        paceStrVal = paceMin + ':' + (paceSec<10?'0':'') + paceSec;
      }

      var row = [id, String(total), String(totalRunMeters), String(totalDist), finishStr, paceStrVal];
      for (j=0;j<maxLaps;j++){
        row.push(rr.laps[j] != null ? msToMMSS(rr.laps[j]) : '');
      }
      rows.push(row);
    }

    var csv = '';
    for (var rIdx=0; rIdx<rows.length; rIdx++){
      var cols = rows[rIdx];
      var parts = [];
      for (var cIdx=0; cIdx<cols.length; cIdx++){
        var s = String(cols[cIdx]);
        if (s.indexOf(',') !== -1) s = '"' + s.replace(/"/g,'""') + '"';
        parts.push(s);
      }
      csv += parts.join(',') + '\n';
    }

    var encoded = encodeURIComponent(csv);
    var a = document.createElement('a');
    a.href = 'data:text/csv;charset=utf-8,' + encoded;
    a.download  = 'topcodes_laps_' + new Date().toISOString().replace(/[:.]/g,'-') + '.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();

    setStatus('CSV exported.');
  });

  function buildSummaryData(){
    var ids = Object.keys(runners).sort(function(a,b){ return Number(a)-Number(b); });
    if (!ids.length) return null;

    var runnersArr = [];
    for (var k=0;k<ids.length;k++){
      var id = ids[k];
      var r  = runners[id];
      runnersArr.push({
        id: id,
        totalLaps: r.totalLaps,
        finished: !!r.finished,
        splitsMs: r.laps.slice()
      });
    }

    return {
      createdAt: new Date().toISOString(),
      runDistanceMeters: runDistanceMeters,
      lapsConfig: parseInt(lapsSel.value,10),
      runners: runnersArr
    };
  }

  summaryBtn.addEventListener('click', function(){
    var data = buildSummaryData();
    if (!data){ setStatus('No data available for summary.'); return; }
    try{
      localStorage.setItem('topcodesLapSummaryV1', JSON.stringify(data));
      window.open('detailedsummary.html', '_blank');
    }catch(e){
      console.error(e);
      setStatus('Unable to save summary data. Check storage settings.');
    }
  });

  window.addEventListener('resize', function(){
    var wasActive = cameraActive;
    resizeCanvas();

    // If camera is active, restart to request new resolution matching new canvas size
    // (keeps view sharp and prevents “small video in big canvas”)
    if (wasActive){
      setStatus('Resizing… restarting camera for best quality.');
      restartCamera();
    }
  });

  window.addEventListener('beforeunload', function(){
    stopCamera();
  });

  // Initial setup
  resizeCanvas();
  updateLapInfo();
  setStatus('Idle. Tap "Enable Camera". TopCodes only (no QR/barcodes). Note: Camera requires HTTPS or localhost.');
})();
</script>
</body>
</html>
