<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>AprilTag Lap Counter</title>
<style>
  :root{ --accent:#0077a9; --bg:#f7f9fb }
  *{ box-sizing:border-box }
  body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:var(--bg); color:#111 }
  .bar{ position:sticky; top:0; z-index:20; background:#fff; border-bottom:1px solid #e6eef6; padding:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  button{ height:40px; min-width:100px; padding:0 12px; font-weight:700; font-size:14px; color:#fff; background:var(--accent); border:0; border-radius:10px; cursor:pointer }
  button.secondary{ background:#6c757d }
  select,input[type=number]{ height:40px; padding:0 8px; border-radius:10px; border:1px solid #d7e3ea; background:#fff }
  .timer{ font-variant-numeric:tabular-nums; font-weight:700; min-width:80px; text-align:center; }
  .wrap{ background:#000; display:flex; justify-content:center; align-items:center }
  canvas#view{ display:block; width:100%; height:auto; touch-action:none; background:#000 }
  .panel{ padding:12px }
  .tbl{ max-height:44vh; overflow:auto; background:#fff; border:1px solid #e6eef6; border-radius:10px }
  table{ width:100%; border-collapse:collapse }
  thead th{ position:sticky; top:0; z-index:1; background:var(--accent); color:#fff; font-weight:700; padding:8px }
  th,td{ padding:8px; text-align:center; border-bottom:1px solid #f0f4f6; font-size:14px }
  tr.done{ background:#eaf8f3 }
  .log{ font-size:12px; color:#333; margin-top:8px; white-space:pre-wrap; max-height:12vh; overflow:auto; background:#fff; border:1px solid #e6eef6; padding:8px; border-radius:8px }
  .muted{ color:#666; font-size:13px }
  .status{ padding:6px 10px; border-radius:999px; background:#eaf2f8; color:#034c66; font-weight:700 }
  .small{ font-size:13px; color:#334 }
</style>
</head>
<body>
  <div class="bar">
    <button id="enableBtn">Enable Camera</button>
    <button id="startBtn" class="secondary" disabled>Start</button>
    <button id="stopBtn" class="secondary" disabled>Stop</button>
    <div style="display:flex;align-items:center;gap:8px;margin-left:8px">
      <div class="timer" id="timer">00:00</div>
      <div class="small">Laps:</div>
      <select id="reqLaps">
        <!-- options 1..20 -->
        <script>for(let i=1;i<=20;i++){document.write(`<option value="${i}">${i}</option>`)}</script>
      </select>
    </div>
    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <div class="status" id="status">Idle</div>
    </div>
  </div>

  <div style="padding:8px;background:#fff;border-bottom:1px solid #e6eef6;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
    <label class="small">Cooldown (ms): <input id="cooldown" type="number" value="2000" min="100" style="width:110px"></label>
    <label class="small">Detect every N frames: <input id="detectEvery" type="number" value="2" min="1" style="width:70px"></label>
    <label class="small" title="Tolerance in pixels from guide line">Line tolerance (px): <input id="tol" type="number" value="24" min="4" style="width:70px"></label>
  </div>

  <div class="wrap">
    <canvas id="view"></canvas>
  </div>

  <div class="panel">
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <button id="exportBtn" class="secondary" disabled>Export CSV</button>
      <div class="muted">Export enabled only after Stop.</div>
    </div>

    <div class="tbl">
      <table>
        <thead><tr><th>Tag ID</th><th>Laps</th><th>Finish</th></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <div class="log" id="log">Logs will appear here.</div>
  </div>

  <!-- AprilTag JS (WASM) -->
  <script defer src="https://unpkg.com/apriltag-js@0.1.4/dist/apriltag.min.js"></script>

  <script>
  // DOM
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const enableBtn = document.getElementById('enableBtn');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const exportBtn = document.getElementById('exportBtn');
  const reqLaps = document.getElementById('reqLaps');
  const timerEl = document.getElementById('timer');
  const statusEl = document.getElementById('status');
  const tbody = document.getElementById('tbody');
  const logEl = document.getElementById('log');
  const cooldownInput = document.getElementById('cooldown');
  const detectEveryInput = document.getElementById('detectEvery');
  const tolInput = document.getElementById('tol');

  // State
  let stream = null, video = null, w = 0, h = 0, guideY = 0;
  let running = false, counting = false, startTime = 0, timerTick = null;
  let detector = null;
  const runners = {}; // id -> { laps, last, finishMs, finishStr, done }
  const DEFAULT_COOLDOWN = 2000;
  let frameCount = 0;

  const log = (...a) => { console.log(...a); logEl.textContent = (logEl.textContent + '\n' + a.join(' ')).slice(-4000); };

  function setStatus(s){ statusEl.textContent = s; }

  function msToHMS(ms){
    if (ms === undefined || ms === null || ms === '-') return '-';
    const sec = Math.floor(ms/1000);
    const mm = String(Math.floor(sec/60)).padStart(2,'0');
    const ss = String(sec%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  // Ensure table row
  function ensureRow(id){
    if (runners[id]) return;
    runners[id] = { laps:0, last:0, finishMs:null, finishStr:'-', done:false };
    const tr = document.createElement('tr');
    tr.id = `r-${id}`;
    tr.innerHTML = `<td>${id}</td><td id="laps-${id}">0</td><td id="fin-${id}">-</td>`;
    tbody.appendChild(tr);
  }

  function updateRow(id){
    document.getElementById(`laps-${id}`).textContent = runners[id].laps;
    document.getElementById(`fin-${id}`).textContent = runners[id].finishStr;
    if (runners[id].done){
      document.getElementById(`r-${id}`).classList.add('done');
    }
  }

  // Counting logic
  function getCooldown(){ return Math.max(50, parseInt(cooldownInput.value || DEFAULT_COOLDOWN, 10)); }
  function getDetectEvery(){ return Math.max(1, parseInt(detectEveryInput.value || '2', 10)); }
  function getTol(){ return Math.max(4, parseInt(tolInput.value || '24', 10)); }

  function countLap(id){
    if (!counting) return;
    const now = Date.now();
    const r = runners[id];
    if (r.done) return;
    if (now - r.last < getCooldown()) return;
    r.laps++;
    r.last = now;
    if (r.laps >= parseInt(reqLaps.value, 10)){
      r.done = true;
      r.finishMs = now - startTime;
      r.finishStr = msToHMS(r.finishMs);
    }
    updateRow(id);
    log(`Tag ${id} lap ${r.laps}${r.done ? ' (finished @'+r.finishStr+')' : ''}`);
  }

  // Camera + detector
  async function waitForApriltag(timeoutMs = 5000){
    const start = Date.now();
    while (Date.now() - start < timeoutMs){
      if (window.apriltag && typeof window.apriltag.Detector === 'function') return true;
      await new Promise(r => setTimeout(r, 120));
    }
    return false;
  }

  async function enableCamera(){
    try {
      // Request camera
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: 'environment' }, width: { ideal:1280 }, height:{ ideal:720 } },
        audio: false
      });

      // Hidden video element (we draw to canvas)
      video = document.createElement('video');
      video.style.display = 'none';
      video.srcObject = stream;
      video.playsInline = true;
      video.muted = true;
      document.body.appendChild(video);

      await video.play();
      await new Promise(r => video.onloadedmetadata = r);

      // Setup canvas
      w = video.videoWidth || 1280;
      h = video.videoHeight || 720;
      canvas.width = w; canvas.height = h;
      guideY = Math.round(h * 0.7);

      setStatus('Loading detector...');
      const ok = await waitForApriltag(5000);
      if (!ok){
        alert('AprilTag library failed to load. Check network.');
        setStatus('Detector failed');
        return;
      }
      detector = new window.apriltag.Detector({ families: ['tag36h11'] });
      setStatus('Ready');
      enableBtn.disabled = true;
      startBtn.disabled = false;
      stopBtn.disabled = false;
      running = true;
      requestAnimationFrame(loop);
      log('Camera enabled', w + 'x' + h);
    } catch (e) {
      console.error(e);
      alert('Camera error: ' + (e.message || e));
      setStatus('Camera error');
    }
  }

  function stopCamera(){
    if (stream){
      stream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
    }
    stream = null;
    if (video){ try{ video.pause(); video.srcObject = null; video.remove(); }catch(e){} }
    video = null;
    running = false;
    setStatus('Camera stopped');
    enableBtn.disabled = false;
    startBtn.disabled = true;
    stopBtn.disabled = true;
  }

  // Main render + detect loop
  function loop(){
    if (!running) return;
    // draw frame
    if (video && video.readyState >= 2){
      ctx.drawImage(video, 0, 0, w, h);
    } else {
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
    }

    // draw guide line
    ctx.strokeStyle = 'red';
    ctx.lineWidth = Math.max(3, h/240);
    ctx.beginPath();
    ctx.moveTo(0, guideY);
    ctx.lineTo(w, guideY);
    ctx.stroke();

    // detect every N frames
    frameCount++;
    if (detector && (frameCount % getDetectEvery() === 0) && video && video.readyState >= 2){
      let frame = null;
      try {
        frame = ctx.getImageData(0,0,w,h);
      } catch (e) {
        // Some browsers can throw if canvas tainted. Report and bail detection.
        console.error('getImageData error', e);
      }
      if (frame){
        let dets = [];
        try {
          dets = detector.detect(frame) || [];
        } catch (e) {
          console.warn('Detector error', e);
        }
        if (dets.length){
          ctx.save();
          ctx.strokeStyle = 'lime';
          ctx.fillStyle = 'rgba(0,255,0,0.2)';
          ctx.lineWidth = Math.max(2, h/360);
          for (const d of dets){
            const cs = d.corners || d.c || [];
            let cx = 0, cy = 0;
            for (const c of cs){ cx += c.x; cy += c.y; }
            const n = Math.max(1, cs.length);
            cx /= n; cy /= n;

            // draw center dot
            ctx.beginPath(); ctx.arc(cx, cy, Math.max(4, h/200), 0, Math.PI*2); ctx.fill();

            // draw quad
            if (cs.length === 4){
              ctx.beginPath(); ctx.moveTo(cs[0].x, cs[0].y);
              for(let i=1;i<4;i++) ctx.lineTo(cs[i].x, cs[i].y);
              ctx.closePath(); ctx.stroke();
            }

            const id = (d.id ?? d.tag_id ?? -1);
            ensureRow(id);

            // count when crossing guide line within tolerance
            if (counting && Math.abs(cy - guideY) <= getTol()){
              countLap(id);
            }
          }
          ctx.restore();
        }
      }
    }

    requestAnimationFrame(loop);
  }

  // Timer
  function startTimer(){
    startTime = Date.now();
    timerEl.textContent = '00:00';
    timerTick = setInterval(() => {
      timerEl.textContent = msToHMS(Date.now() - startTime);
    }, 250);
  }
  function stopTimer(){
    if (timerTick) clearInterval(timerTick);
    timerTick = null;
  }

  // Start / Stop counting
  function startCounting(){
    if (!detector || !stream) { alert('Enable camera first'); return; }
    if (counting) return;
    counting = true;
    startTimer();
    setStatus('Counting');
    log('Counting started at ' + new Date().toISOString());
    exportBtn.disabled = true;
  }

  function stopCounting(){
    if (!counting) return;
    counting = false;
    stopTimer();
    setStatus('Stopped');

    // Mark DNF for anyone who didn't finish required laps
    const req = parseInt(reqLaps.value, 10);
    for (const id of Object.keys(runners)){
      const r = runners[id];
      if (!r.done){
        r.finishStr = 'DNF';
        r.finishMs = null;
        r.done = false; // keep done false, but mark finishStr
        updateRow(id);
      }
    }

    log('Counting stopped at ' + new Date().toISOString());
    exportBtn.disabled = false;
  }

  // Export CSV
  function exportCSV(){
    // CSV columns: tag_id,laps,finish_str,finish_ms
    const rows = [['tag_id','laps','finish','finish_ms']];
    for (const id of Object.keys(runners)){
      const r = runners[id];
      rows.push([id, r.laps, r.finishStr || '-', r.finishMs === null ? '' : r.finishMs]);
    }
    const csv = rows.map(r => r.map(cell => {
      if (typeof cell === 'string' && cell.includes(',')) return `"${cell.replace(/"/g,'""')}"`;
      return cell;
    }).join(',')).join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `laps_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    setStatus('CSV exported');
    log('Exported CSV with', Object.keys(runners).length, 'entries');
  }

  // Events
  enableBtn.addEventListener('click', enableCamera);
  startBtn.addEventListener('click', () => {
    startCounting();
  });
  stopBtn.addEventListener('click', () => {
    stopCounting();
  });
  exportBtn.addEventListener('click', () => {
    exportCSV();
  });

  // stop camera on unload
  window.addEventListener('beforeunload', () => {
    if (stream) stream.getTracks().forEach(t => t.stop());
  });

  // initial status
  setStatus('Idle');
  log('Ready. Click "Enable Camera" to begin. Use Start to start counting, Stop to stop and enable CSV export.');

  </script>
</body>
</html>
