<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArUco Lap Counter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }
        #container {
            width: 100%;
            max-width: 800px;
        }
        #video {
            display: none;
        }
        #canvas {
            width: 100%;
            height: auto;
            border: 1px solid #ccc;
        }
        #controls {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
        }
        #controls input, #controls button {
            padding: 10px;
            font-size: 16px;
        }
        #timer {
            font-size: 24px;
            text-align: center;
            margin: 10px 0;
        }
        #results {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        #results th, #results td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        #results th {
            background-color: #f2f2f2;
        }
        #status {
            text-align: center;
            margin: 10px 0;
        }
    </style>
    <script async src="https://docs.opencv.org/4.10.0/opencv.js" onload="onOpenCvReady();"></script>
</head>
<body>
    <div id="container">
        <h1>ArUco Lap Counter</h1>
        <video id="video" playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="controls">
            <label for="requiredLaps">Required Laps:</label>
            <input type="number" id="requiredLaps" value="10" min="1">
            <button id="startBtn" disabled>Start</button>
            <button id="stopBtn" disabled>Stop</button>
        </div>
        <div id="timer">00:00</div>
        <table id="results">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Laps</th>
                    <th>Finish Time</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        <div id="status">Loading OpenCV...</div>
    </div>
    <script>
        let video, canvas, ctx, stream;
        let cap, frame, corners, ids, rejected, dictionary, detector;
        let running = false;
        let startPerf = 0;
        let timerInterval;
        let trackers = new Map();
        let requiredLaps = 10;
        let cooldown = 2; // seconds
        let lineYFraction = 0.7;
        let uiInterval;

        function onOpenCvReady() {
            document.getElementById('status').innerText = 'OpenCV.js is ready.';
            document.getElementById('startBtn').disabled = false;
            cv['onRuntimeInitialized'] = () => {
                initializeOpenCV();
            };
        }

        function initializeOpenCV() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            dictionary = cv.aruco.getPredefinedDictionary(cv.aruco.DICT_6X6_50);
            detector = new cv.aruco.ArucoDetector(dictionary);

            cap = new cv.VideoCapture(video);
            frame = new cv.Mat();
            corners = new cv.MatVector();
            ids = new cv.Mat();
            rejected = new cv.MatVector();
        }

        async function startCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                await video.play();
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                frame = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
            } catch (err) {
                console.error('Camera error:', err);
                document.getElementById('status').innerText = 'Error accessing camera.';
            }
        }

        function processVideo() {
            if (!running) return;

            cap.read(frame);

            detector.detectMarkers(frame, corners, ids, rejected);

            const width = canvas.width;
            const height = canvas.height;
            const lineY = Math.floor(lineYFraction * height);

            if (ids.rows > 0) {
                const currentTime = performance.now() / 1000;

                for (let i = 0; i < ids.rows; i++) {
                    const id = ids.data32S[i];
                    if (!trackers.has(id)) {
                        trackers.set(id, {
                            laps: 0,
                            finishTime: null,
                            prevY: null,
                            lastCountTime: 0
                        });
                    }
                    const tracker = trackers.get(id);

                    const markerCorners = corners.get(i);
                    let sumY = 0;
                    for (let j = 0; j < 4; j++) {
                        sumY += markerCorners.data32F[j * 2 + 1];
                    }
                    const centerY = sumY / 4;

                    if (tracker.prevY !== null &&
                        tracker.prevY > lineY &&
                        centerY <= lineY &&
                        currentTime - tracker.lastCountTime > cooldown) {
                        tracker.laps++;
                        tracker.lastCountTime = currentTime;
                        const elapsed = (performance.now() - startPerf) / 1000;
                        if (tracker.laps >= requiredLaps && tracker.finishTime === null) {
                            tracker.finishTime = elapsed;
                        }
                    }
                    tracker.prevY = centerY;
                }
            }

            // Draw detections and line
            if (ids.rows > 0) {
                cv.aruco.drawDetectedMarkers(frame, corners, ids, new cv.Scalar(0, 255, 0));
            }
            cv.line(frame, new cv.Point(0, lineY), new cv.Point(width, lineY), new cv.Scalar(255, 0, 0, 255), 2);

            cv.imshow('canvas', frame);

            requestAnimationFrame(processVideo);
        }

        function updateTimer() {
            const elapsed = (performance.now() - startPerf) / 1000;
            document.getElementById('timer').innerText = formatTime(elapsed);
        }

        function updateUI() {
            const tbody = document.querySelector('#results tbody');
            tbody.innerHTML = '';

            // Sort: finished first by finishTime asc, then unfinished by ID asc
            const entries = Array.from(trackers.entries());
            entries.sort((a, b) => {
                if (a[1].finishTime !== null && b[1].finishTime !== null) {
                    return a[1].finishTime - b[1].finishTime;
                } else if (a[1].finishTime !== null) {
                    return -1;
                } else if (b[1].finishTime !== null) {
                    return 1;
                } else {
                    return a[0] - b[0];
                }
            });

            entries.forEach(([id, tracker]) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${id}</td>
                    <td>${tracker.laps}</td>
                    <td>${tracker.finishTime !== null ? formatTime(tracker.finishTime) : '-'}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            if (running) return;
            requiredLaps = parseInt(document.getElementById('requiredLaps').value) || 10;
            await startCamera();
            running = true;
            startPerf = performance.now();
            timerInterval = setInterval(updateTimer, 1000);
            uiInterval = setInterval(updateUI, 500);
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            requestAnimationFrame(processVideo);
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            running = false;
            clearInterval(timerInterval);
            clearInterval(uiInterval);
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            updateUI(); // Final update
        });
    </script>
</body>
</html>