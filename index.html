<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>QR Lap Tracker — Responsive + Recording</title>
<style>
  :root { --accent:#015871; --bg:#f7f7f7; --card:#ffffff; --line:red; }
  *{ box-sizing:border-box }
  body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:var(--bg); color:#111 }
  .app{
    display:grid;
    grid-template-areas:
      "top"
      "list";
    grid-template-rows: 25vh 1fr;    /* Portrait: video/buttons in top quarter */
    grid-template-columns: 1fr;
    min-height:100vh;
    gap:10px;
  }
  header.top{
    grid-area:top;
    display:grid;
    grid-template-areas:"video controls";
    grid-template-columns: 1fr auto;
    gap:10px;
    padding:10px;
    background:var(--card);
    border-bottom:1px solid #eaeaea;
  }
  .videoWrap{ grid-area:video; position:relative; background:#000; border-radius:10px; overflow:hidden; }
  video#cam{ width:100%; height:100%; object-fit:cover; display:block; }
  canvas#overlay{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }
  .controls{ grid-area:controls; display:flex; flex-direction:column; gap:8px; justify-content:flex-start; align-items:stretch; }
  .controls .row{ display:flex; gap:8px; flex-wrap:wrap; }
  button{
    background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:10px; font-weight:700; font-size:16px;
  }
  button.secondary{ background:#666 }
  select, .timer{
    height:44px; padding:0 10px; border:1px solid #ccc; border-radius:10px; background:#fff; font-size:16px; display:flex; align-items:center;
  }
  .timer{ font-variant-numeric:tabular-nums; font-weight:700; min-width:90px; justify-content:center; }
  main.list{
    grid-area:list; padding:10px;
  }
  .tableCard{
    background:var(--card); border:1px solid #eee; border-radius:12px; overflow:hidden; height:100%; display:flex; flex-direction:column;
  }
  .tableCard header{ background:var(--accent); color:#fff; padding:10px; font-weight:700 }
  .tableWrap{ overflow:auto; flex:1; }
  table{ width:100%; border-collapse:collapse; }
  th,td{ border-bottom:1px solid #f2f2f2; padding:10px; text-align:center; font-size:14px }
  tr.done{ background:#e9f6ec }
  .status{ padding:10px; font-size:13px; color:#444 }
  .hint{ font-size:12px; color:#666; padding:0 10px 10px; }

  /* LANDSCAPE: video/buttons on left half, table on right half */
  @media (orientation:landscape){
    .app{
      grid-template-areas:"left right";
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 100vh;
      gap:10px;
    }
    header.top{
      grid-area:left;
      grid-template-areas:
        "video"
        "controls";
      grid-template-rows: 1fr auto;
      grid-template-columns: 1fr;
      height:100%;
    }
    main.list{ grid-area:right; }
  }
</style>
</head>
<body>
<div class="app">
  <header class="top">
    <div class="videoWrap">
      <video id="cam" playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>
    <div class="controls">
      <div class="row">
        <button id="enableBtn">Enable Camera</button>
        <button id="startBtn" class="secondary" disabled>Start</button>
        <button id="stopBtn" class="secondary" disabled>Stop</button>
      </div>
      <div class="row">
        <label class="timer" id="timer">00:00</label>
        <select id="lapsSelect" title="Required laps">
          <!-- 1..20 -->
        </select>
        <select id="lineSelect" title="Start line position">
          <option value="0.7" selected>Line @ 70% height</option>
          <option value="0.5">Line @ 50% height</option>
          <option value="0.3">Line @ 30% height</option>
        </select>
      </div>
      <div class="status" id="status">Idle — tap “Enable Camera”.</div>
      <div class="hint">Tip: Print **QR codes** large (A6/A5). The QR <b>text</b> is treated as the <b>runner ID</b>.</div>
    </div>
  </header>

  <main class="list">
    <div class="tableCard">
      <header>Scanned Runners</header>
      <div class="tableWrap">
        <table>
          <thead><tr><th>Runner ID (QR text)</th><th>Laps</th><th>Finish Time</th></tr></thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>
  </main>
</div>

<!-- jsQR for QR detection -->
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" defer></script>
<script>
(function(){
  // DOM
  const video     = document.getElementById('cam');
  const overlay   = document.getElementById('overlay');
  const octx      = overlay.getContext('2d');
  const tbody     = document.getElementById('tbody');
  const statusEl  = document.getElementById('status');
  const timerEl   = document.getElementById('timer');
  const enableBtn = document.getElementById('enableBtn');
  const startBtn  = document.getElementById('startBtn');
  const stopBtn   = document.getElementById('stopBtn');
  const lapsSelect= document.getElementById('lapsSelect');
  const lineSelect= document.getElementById('lineSelect');

  // Populate laps 1..20
  for(let i=1;i<=20;i++){
    const opt=document.createElement('option'); opt.value=String(i); opt.textContent=`${i} lap${i>1?'s':''}`;
    if(i===4) opt.selected=true;
    lapsSelect.appendChild(opt);
  }

  // State
  let stream=null;
  let runningPreview=false, counting=false;
  let guideRatio=0.7;  // as fraction of overlay height
  let guideY=0;        // pixels (computed)
  let w=0, h=0;
  let frameCount=0;
  const runners={}; // id -> {laps,last,done,finish}
  const COOLDOWN=1500; // ms per ID

  // Recording
  let mediaRecorder=null, chunks=[], recording=false;

  // Offscreen processing canvas (full-res)
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', { willReadFrequently:true });

  // Utils
  const setStatus=(...a)=>{ statusEl.textContent=a.join(' '); console.log(...a); };
  function fitOverlay(){
    // Match overlay size to displayed video box (client size), for drawing the red line
    const rect = video.getBoundingClientRect();
    overlay.width  = video.clientWidth;
    overlay.height = video.clientHeight;
    guideY = Math.round(overlay.height * guideRatio);
  }
  function updateTimer(startMs){
    const s = Math.floor((Date.now()-startMs)/1000);
    const mm=String(Math.floor(s/60)).padStart(2,'0');
    const ss=String(s%60).padStart(2,'0');
    timerEl.textContent=`${mm}:${ss}`;
  }
  function ensureRow(id){
    if (runners[id]) return;
    runners[id]={ laps:0, last:0, done:false, finish:'-' };
    const tr=document.createElement('tr'); tr.id='r-'+id;
    tr.innerHTML=`<td class="id">${id}</td><td id="laps-${id}">0</td><td id="fin-${id}">-</td>`;
    tbody.appendChild(tr);
  }
  function updateRow(id){
    document.getElementById('laps-'+id).textContent = runners[id].laps;
    document.getElementById('fin-'+id).textContent  = runners[id].finish;
    if (runners[id].done) document.getElementById('r-'+id).classList.add('done');
  }
  function countLap(id, startMs){
    const now=Date.now();
    const r=runners[id];
    if (r.done) return;
    if (now - r.last < COOLDOWN) return;
    r.laps++; r.last=now;
    const req=parseInt(lapsSelect.value,10);
    if (r.laps>=req){ r.done=true; r.finish = timerEl.textContent; }
    updateRow(id);
    setStatus(`Counted lap for ${id} (${r.laps}/${req})`);
  }
  function markDNFForUnfinished(){
    for (const id of Object.keys(runners)){
      if (!runners[id].done){ runners[id].finish='DNF'; updateRow(id); }
    }
  }

  // Camera + recording
  async function enableCamera(){
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720} },
        audio: false
      });
    }catch(e){
      setStatus('Camera error: '+(e.message||e)); enableBtn.disabled=false; return;
    }

    video.srcObject=stream;
    video.muted = true; video.playsInline = true; // iOS
    await video.play();
    await new Promise(r=> (video.readyState>=2? r() : video.onloadedmetadata=r) );

    // processing canvas at sensor resolution
    w = video.videoWidth  || 1280;
    h = video.videoHeight || 720;
    proc.width=w; proc.height=h;

    // draw overlay line at displayed size (¼ screen area)
    fitOverlay();
    drawOverlayLine();

    enableBtn.disabled=true;
    startBtn.disabled=false;
    stopBtn.disabled=true;
    runningPreview=true;
    requestAnimationFrame(previewLoop);

    setStatus('Camera ready. Press Start to count + record.');
  }

  function drawOverlayLine(){
    // Draw the guide line over the displayed video (not used for processing)
    octx.clearRect(0,0,overlay.width,overlay.height);
    octx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--line') || 'red';
    octx.lineWidth = Math.max(3, overlay.height/220);
    octx.beginPath();
    octx.moveTo(0, guideY);
    octx.lineTo(overlay.width, guideY);
    octx.stroke();
  }

  function previewLoop(){
    if (!runningPreview) return;

    // Keep the red line visible and scaled to current element size
    if (frameCount % 15 === 0){ fitOverlay(); drawOverlayLine(); }

    // Detection throttled for performance (every 2nd frame)
    frameCount++;
    if (video.readyState >= 2 && window.jsQR && (frameCount % 2 === 0)){
      // draw the current frame to the offscreen processing canvas at full res
      pctx.drawImage(video, 0, 0, w, h);
      const frame = pctx.getImageData(0, 0, w, h);
      const qr = jsQR(frame.data, w, h, { inversionAttempts: 'attemptBoth' });
      if (qr && qr.location){
        // Draw minimal visual marker (in displayed overlay space)
        const scaleX = overlay.width / w;
        const scaleY = overlay.height / h;
        const cx = (qr.location.topLeftCorner.x + qr.location.topRightCorner.x +
                    qr.location.bottomLeftCorner.x + qr.location.bottomRightCorner.x) / 4;
        const cy = (qr.location.topLeftCorner.y + qr.location.topRightCorner.y +
                    qr.location.bottomLeftCorner.y + qr.location.bottomRightCorner.y) / 4;

        // dot
        octx.save();
        octx.fillStyle='rgba(0,255,0,0.35)';
        octx.beginPath();
        octx.arc(cx*scaleX, cy*scaleY, Math.max(4, overlay.height/200), 0, Math.PI*2);
        octx.fill();
        octx.restore();

        // Counting if started and crosses virtual line
        if (counting){
          const id = String(qr.data).trim();
          if (id){
            ensureRow(id);
            const req = parseInt(lapsSelect.value,10);
            if (Math.abs((cy*scaleY) - guideY) < Math.max(16, overlay.height/60)){
              countLap(id);
            }
          }
        }
      }
    }

    requestAnimationFrame(previewLoop);
  }

  function startRecording(){
    if (!stream){ setStatus('No camera stream to record.'); return; }
    if (typeof MediaRecorder === 'undefined'){ setStatus('MediaRecorder not supported on this device.'); return; }
    // Some mobile browsers prefer specific mime types
    const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9'
               : MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8'
               : MediaRecorder.isTypeSupported('video/webm')            ? 'video/webm'
               : '';
    try{
      mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : {});
    }catch(e){
      setStatus('Failed to start recording: '+(e.message||e)); return;
    }
    chunks=[];
    mediaRecorder.ondataavailable = (ev)=>{ if(ev.data && ev.data.size>0) chunks.push(ev.data); };
    mediaRecorder.onstop = ()=>{
      const blob = new Blob(chunks, { type: chunks[0]?.type || 'video/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.href = url; a.download = `run_session_${ts}.webm`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
      setStatus('Recording saved.');
    };
    mediaRecorder.start(1000); // timeslice
    recording=true;
    setStatus('Recording…');
  }

  function stopRecording(){
    if (mediaRecorder && recording){
      recording=false;
      try{ mediaRecorder.stop(); }catch(e){}
    }
  }

  // UI handlers
  enableBtn.addEventListener('click', async ()=>{
    enableBtn.disabled=true;
    await enableCamera();
  });

  startBtn.addEventListener('click', ()=>{
    if (!stream){ setStatus('Enable camera first.'); return; }
    // Reset laps/timer state for a new run
    for (const id of Object.keys(runners)){
      runners[id].laps=0; runners[id].last=0; runners[id].done=false; runners[id].finish='-';
      updateRow(id);
      document.getElementById('r-'+id)?.classList.remove('done');
    }
    counting=true;
    const t0=Date.now();
    timerEl.textContent='00:00';
    const tick = setInterval(()=> updateTimer(t0), 1000);
    startBtn.dataset.ticker = String(tick);
    startBtn.disabled=true; stopBtn.disabled=false;
    startRecording();
    setStatus('Counting & recording started.');
  });

  stopBtn.addEventListener('click', ()=>{
    if (!counting) return;
    counting=false;
    // clear timer interval
    const tick = Number(startBtn.dataset.ticker || 0);
    if (tick) clearInterval(tick);
    // mark DNF for unfinished
    markDNFForUnfinished();
    // stop and auto-save recording
    stopRecording();
    startBtn.disabled=false; stopBtn.disabled=true;
    setStatus('Stopped — results locked and video saved.');
  });

  // Adjust virtual line on change
  lineSelect.addEventListener('change', ()=>{
    guideRatio = parseFloat(lineSelect.value) || 0.7;
    fitOverlay(); drawOverlayLine();
  });

  // Keep overlay aligned on resize/orientation
  window.addEventListener('resize', ()=>{ fitOverlay(); drawOverlayLine(); });
  window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ fitOverlay(); drawOverlayLine(); }, 350); });

  // Convenience: warn if jsQR isn’t ready (very rare)
  window.addEventListener('load', ()=>{
    if (!window.jsQR){
      setStatus('Loading jsQR… (if this persists, check your network)'); 
    }
  });
})();
</script>
</body>
</html>